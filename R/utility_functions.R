# Common utility functions

#' @title Filter to remove minor satellite peaks
#' @description Remove minor signals (e.g., satellite peaks) that were reported by IsoX
#' @param dataset A data frame or tibble produced from IsoX data by `orbi_simplify_isox()`
#' @details The `orbi_filter_satellite_peaks()` function removes minor signals for an isotopocule that have been reported by IsoX.
#' These are often small `satellite peaks` generated by the Fourier transform.
#'
#' If there are signal of high intensity or very many signals, this can indicate that the m/z and tolerance setting used for processing .raw files with IsoX were incorrect.
#'
#'@examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#' orbi_simplify_isox() %>%
#' orbi_filter_satellite_peaks()
#'
#' @return Filtered data frame (tibble)
#' @export
orbi_filter_satellite_peaks <- function(dataset) {

  # safety checks
  if (missing(dataset))
    stop("no dataset supplied", call. = TRUE)
  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)
  if (ncol(dataset) < 8)
    stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
  if (nrow(dataset) < 1)
    stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)


  # check that requires columns are present
  req_cols <- c("filename", "compound", "scan.no", "time.min", "isotopocule", "ions.incremental", "tic", "it.ms")

  missing_cols <- setdiff(req_cols, names(dataset))

  if (length(missing_cols) > 0) {
    paste0("Missing required column(s): ", paste(missing_cols, collapse = ", ")) %>%
      stop(call. = FALSE)
  }

  tryCatch(
    df.out <- dataset %>% ungroup %>%
      dplyr::group_by(.data$filename,
                      .data$compound,
                      .data$scan.no,
                      .data$isotopocule) %>%
      dplyr::filter(.data$ions.incremental == max(.data$ions.incremental)),
    warning = function(w) {
      stop("something went wrong: ", w$message, call. = TRUE)
    }
  )

  return(df.out)
}



#' @title Filter to remove weak isotopocules
#' @description The function `orbi_filter_weak_isotopocules()` removes isotopocules that are not consistently detected in most scans
#'
#' @param dataset A simplified IsoX data frame to be processed
#' @param min_percent A number between 0 and 90. Isotopocule must be observed in at least this percentage of scans (please note: the percentage is defined relative to the most commonly observed isotopocule of the compound)
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#'                      orbi_simplify_isox() %>%
#'                      orbi_filter_weak_isotopocules(min_percent = 2)
#'
#' @details The input `dataset` is expected to have at least these 8 columns: `filename`, `scan.no`, `time.min`, `compound`, `isotopocule`, `ions.incremental`, `tic`, `it.ms`.
#'
#' @return Filtered tibble
#' @export
orbi_filter_weak_isotopocules <-
  function(dataset, min_percent) {

    # safety checks
    if (missing(dataset))
      stop("no dataset supplied", call. = TRUE)
    if (is.data.frame(dataset) == FALSE)
      stop("dataset must be a data frame",  call. = TRUE)
    if (ncol(dataset) < 8)
      stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
    if (nrow(dataset) < 1)
      stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)

    if (missing(min_percent))
      stop("value for min_percent missing", call. = TRUE)

    if (!(is.numeric(min_percent)))
      stop("min_percent needs to be a number", call. = TRUE)
    if (!(min_percent >= 0 && min_percent <=90))
      stop("min_percent needs to be between 0 and 90 ", call. = TRUE)


    # check that requires columns are present
    req_cols <- c("filename", "compound", "scan.no", "time.min", "isotopocule", "ions.incremental", "tic", "it.ms")

    missing_cols <- setdiff(req_cols, names(dataset))

    if (length(missing_cols) > 0) {
      paste0("Missing required column(s): ", paste(missing_cols, collapse = ", ")) %>%
        stop(call. = FALSE)
    }



    #Optional groupings

    tryCatch(

      {


        df.group <- dataset  %>% ungroup() %>%
          dplyr::group_by(.data$filename,
                          .data$compound, .add = TRUE)


        {if ("block" %in% names(dataset))

            #ensure block is defined as a factor

            df.group <-
            df.group  %>% mutate(block = as.factor(.data$block)) %>%
            dplyr::group_by(.data$block,
                            .add = TRUE)
          }

        {if ("segment" %in% names(dataset))

            #ensure segment is defined as a factor

            df.group <-
            df.group  %>% mutate(segment = as.factor(.data$segment)) %>%
            dplyr::group_by(.data$segment,
                            .add = TRUE)
        }

        {if ("injection" %in% names(dataset))

            #ensure injection is defined as a factor

            df.group <-
            df.group  %>% mutate(injection = as.factor(.data$injection)) %>%
            dplyr::group_by(.data$injection,
                            .add = TRUE)
        }
      },


      warning = function(w) {
        stop("something went wrong looking to add optional groupings: ",
             w$message,
             call. = TRUE)
      }
    )


    tryCatch(

      remove.df <- df.group %>%
          dplyr::mutate(max.scans = length(unique(.data$scan.no))) %>%
          dplyr::group_by(.data$isotopocule, .add = TRUE) %>%
          dplyr::mutate(obs.scans = length(unique(.data$scan.no))) %>%
          dplyr::filter(.data$obs.scans < min_percent / 100 * .data$max.scans) %>%
          dplyr::select(-.data$obs.scans,-.data$max.scans) %>% droplevels() %>% as.data.frame(),
        warning = function(w) {
          stop("something went wrong applying filter min_percent: ", w$message, call. = TRUE)

      }
    )


    tryCatch(
      df.out <-
        dplyr::anti_join(
          dataset,
          remove.df,
          by = c(
            "filename",
            "scan.no",
            "time.min",
            "compound",
            "isotopocule",
            "ions.incremental",
            "tic",
            "it.ms"
          )
        ),
             warning = function(w) {
               stop("something went wrong: ", w$message, call. = TRUE)
             }
    )

    return(df.out)

  }


#' @title Filter to remove extreme scans
#' @description The function `orbi_filter_scan_intensity()` removes extremely high and low intense scans based on TIC x injection time (i.e., ion intensity)
#' @param dataset Simplified IsoX dataset to have `TICxIT` outliers removed
#' @param truncate_extreme A number between 0 and 10. Remove this percentage of scans based on TIC multiplied by injection time.
#' @details Function is intended to remove scans that are outliers. TIC multiplied by injection time serves as an estimate for the number of ions in the Orbitrap.
#'
#' The filter is a basic truncation that removes `x %` of scans with the largest **and** `x %` of scans with the smallest ion estimates. Grouping is by columns `filename` and `compound`.
#'
#' The input `dataset` is expected to have at least these 8 columns: `filename`, `scan.no`, `time.min`, `compound`, `isotopocule`, `ions.incremental`, `tic`, `it.ms`.
#'
#'@examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#' orbi_simplify_isox() %>%
#' orbi_filter_scan_intensity(truncate_extreme = 1)
#'
#' @return Filtered tibble
#' @export
orbi_filter_scan_intensity <- function(dataset, truncate_extreme) {

  # safety checks
  if (missing(dataset))
    stop("no dataset supplied", call. = TRUE)
  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)
  if (ncol(dataset) < 8)
    stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
  if (nrow(dataset) < 1)
    stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)

  if (missing(truncate_extreme))
    stop("value for truncate_extreme missing", call. = TRUE)

  if (!(is.numeric(truncate_extreme)))
    stop("truncate_extreme needs to be a number", call. = TRUE)
  if (!(truncate_extreme >= 0 && truncate_extreme <=10))
    stop("truncate_extremet needs to be between 0 and 10 ", call. = TRUE)



  # check that requires columns are present
  req_cols <- c("filename", "compound", "scan.no", "time.min", "isotopocule", "ions.incremental", "tic", "it.ms")

  missing_cols <- setdiff(req_cols, names(dataset))

  if (length(missing_cols) > 0) {
    paste0("Missing required column(s): ", paste(missing_cols, collapse = ", ")) %>%
      stop(call. = FALSE)
  }


  #Optional groupings

  tryCatch(

    {df.group <- dataset  %>% ungroup() %>%
        dplyr::group_by(.data$filename,
                        .data$compound, .add = TRUE)


      {if ("block" %in% names(dataset))

          #ensure block is defined as a factor

          df.group <-
          df.group  %>% mutate(block = as.factor(.data$block)) %>%
          dplyr::group_by(.data$block,
                          .add = TRUE)
        }

      {if ("segment" %in% names(dataset))

          #ensure segment is defined as a factor

          df.group <-
          df.group  %>% mutate(segment = as.factor(.data$segment)) %>%
          dplyr::group_by(.data$segment,
                          .add = TRUE)
      }

      {if ("injection" %in% names(dataset))

          #ensure injection is defined as a factor

          df.group <-
          df.group  %>% mutate(injection = as.factor(.data$injection)) %>%
          dplyr::group_by(.data$injection,
                          .add = TRUE)
      }
    },


    warning = function(w) {
      stop("something went wrong looking to add optional groupings: ",
           w$message,
           call. = TRUE)
    }
  )

  tryCatch(  df.out <- df.group %>%
               dplyr::mutate(TICxIT = .data$tic * .data$it.ms) %>%
               dplyr::filter(
                 .data$TICxIT > stats::quantile(.data$TICxIT, truncate_extreme / 100) &
                 .data$TICxIT < stats::quantile(.data$TICxIT, 1 - truncate_extreme / 100)
               ) %>%
               dplyr::select(-.data$TICxIT),
    warning = function(w) {
      stop("something went wrong: ", w$message, call. = TRUE)
    }
  )

  return(df.out)
}


# Functions to calculate stats --------------------------------------------

# @title Internal function to calculate standard error
# @description The fuction `calculate_se()` computes a regular standard error
# @keywords internal
# @param x A numeric vector used to calculate a standard error
# @return The calculated standard error

calculate_se <- function(x) {

  # safety checks
  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)


  tryCatch(
    stats::sd(x) / sqrt(length(x)),
    warning = function(w) {
      stop("something went wrong calculating the standard error: ", w$message, call. = TRUE)
    }
  )

}

# @title Internal function to calculate geometric mean
# @description  The function `calculate_gmean()` is used to calculate geometric means
# @keywords internal
# @param x A numeric vector used to calculate the geometric mean
# @return The calculated geometric mean

calculate_gmean <- function(x) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  tryCatch(
    exp(mean(log(x))),
    warning = function(w) {
      stop("something went wrong calculating the geometic mean: ", w$message, call. = TRUE)
    }
  )


}


# @title Internal function to calculate standard deviation (geometric)
# @description  The function `calculate_gsd()` is used to calculate geometric standard deviations
# @keywords internal
# @param x A numeric values used to calculate the geometric standard deviation
# @return The calculated geometric standard deviation
calculate_gsd <- function(x) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  tryCatch(
    exp(mean(log(x)) + stats::sd(log(x))) - exp(mean(log(x))),
    warning = function(w) {
      stop("something went wrong calculating geometric standard deviaton: ", w$message, call. = TRUE)
    }
  )

}

# @title Internal function to calculate standard error (geometric)
# @description  The function `calculate_gse()` is used to calculate geometric standard errors
# @keywords internal
# @param x A vector of values used to calculate geometric standard errors
# @return The calculated geometric standard error
calculate_gse <- function(x) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  tryCatch(
    (exp(mean(log(x)) + stats::sd(log(x))) - exp(mean(log(x)))) / sqrt(length(x)),
    warning = function(w) {
      stop("something went wrong calculating the geometric standard error: ", w$message, call. = TRUE)
    }
  )

}

# @title Internal function for ratio_method `slope`
# @description  The function `calculate_slope()` is used to estimate the slope of x, y values used in a ratio
# @keywords internal
# @param x Vector of values used as ratio nominator
# @param y Vector of values used as ratio denominator
# @details The slope is calculated from a linear regression model that is weighted by the numerator x, using `stats::lm(x ~ y + 0, weights = x)`
# @return The calculated slope, an estimate of the ratio x/y
calculate_slope <- function(x, y) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  if (missing(y))
    stop("input vector for y supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  #basic checks
  if (!(is.vector(y)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(y)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(y) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  if (length(x) != length(y))
    stop("Length of x and y need to be equal", call. = TRUE)

  tryCatch(
    model <- stats::lm(x ~ y + 0, weights = x), #Note order of x and y to get correct slope!

    warning = function(w) {
      stop("something went wrong calculating the ratio as slope using a linear model: ", w$message, call. = TRUE)
    }
  )

  sl <- model$coefficients[[1]]
  return(sl)
}

# @title Internal function for ratio_method `weighted.sum`
# @description The function `calculate_weighted.sum()` is used to calculate ratios by weighted sums of x and y values
# @keywords internal
# @param x A vector of values used as ratio nominator
# @param y A vector of values used as ratio denominator
# @details The weighing function ensures that each scan contributes equal weight to the ratio calculation,
# i.e. scans with more ions in the Orbitrap do not contribute disproportionally to the total sum of x and y that is used to calculate x/y.
# @return The calculated ratio x/y
calculate_weighted.sum <- function(x, y) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  if (missing(y))
    stop("input vector for y supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  #basic checks
  if (!(is.vector(y)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(y)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(y) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  if (length(x) != length(y))
    stop("Length of x and y need to be equal", call. = TRUE)


  df <- cbind(x, y)

  avg.ions <- (sum(df[, 1]) + sum(df[, 2])) / length(df[, 1])

  scan.ions <- (df[, 1] + df[, 2])

  weighted.x <- avg.ions / scan.ions  * as.numeric(df[, 1])
  weighted.y <- avg.ions / scan.ions  * as.numeric(df[, 2])

  tryCatch(
    ratio <- sum(weighted.x) / sum(weighted.y), #Note order of x and y to get correct slope!

    warning = function(w) {
      stop("something went wrong calculating the ratio from weighted sums: ", w$message, call. = TRUE)
    }
  )

  return(ratio)
}

# @title Internal function to calculate ratio
# @description Ratio calculation between isotopocules of interest.
#
# Please note well: The formula used to calculate ion ratios matters! Do not simply use arithmetic mean.
#
# @param numerator Column(s) used as numerator; contains ion counts
# @param denominator Column used as denominator; contains ion counts
# @param ratio_method The desired method of computing the ratio
# @details Description of options for ratio_method:
#
# `mean`: arithmetic mean of ratios from individual scans.
#
# `sum`: sum of all ions of the numerator across all scans divided by the sum of all ions observed for the denominator across all scans.
#
# `geometric.mean`: geometric mean of ratios from individual scans.
#
# `slope`: The ratio is calculated using the slope from a linear model that is weighted by the numerator x, using `stats::lm(x ~ y + 0, weights = x)`.
#
# `weighted.sum`: A derivative of the `sum` option. The weighing function ensures that each scan contributes equal weight to the ratio calculation,
# i.e. scans with more ions in the Orbitrap do not contribute disproportionately to the total `sum` of `x` and `y` that is used to calculate `x/y`.
#
# @examples
# fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
# df <- orbi_read_isox(filepath = fpath) %>%
#                      orbi_simplify_isox() %>%
#                      orbi_define_basepeak(base_peak = "M0")
# df2 <- orbi_calculate_ratio(numerator = df$ions.incremental, denominator = df$basepeak.Ions, ratio_method =  "sum")
#
# @return Calculated ratio between isotopocules defined as numerator(s) and denominator, using one of the ratio methods.
# @export

orbi_calculate_ratio <- function(numerator,
                                 denominator,
                                 ratio_method = c("mean",
                                                  "sum",
                                                  "median",
                                                  "geometric.mean",
                                                  "slope",
                                                  "weighted.sum")) {
  if (missing(numerator))
    stop("no input for numerator supplied", call. = TRUE)

  if (is.numeric(numerator) == FALSE)
    stop("numerator must be a numeric vector",  call. = TRUE)

  if (missing(denominator))
    stop(" no input for denominator supplied", call. = TRUE)

  if (is.numeric(denominator) == FALSE)
    stop("denominator must be a numeric vector",  call. = TRUE)


  tryCatch({
    if (ratio_method == "mean") {
      o <- base::mean(numerator / denominator)
      o
    } else {
      if (ratio_method == "slope") {
        o <- calculate_slope(numerator, denominator)
        o
      } else{
        if (ratio_method == "sum") {
          o <-  base::sum(numerator) / sum(denominator)
          o
        } else{
          if (ratio_method == "geometric.mean") {
            o <- calculate_gmean(numerator / denominator)
            o
          } else{
            if (ratio_method == "weighted.sum") {
              o <- calculate_weighted.sum(numerator, denominator)
              o
            } else{
              if (ratio_method == "median") {
                o <-
                  stats::median(numerator / denominator)
                o
              } else{
                print(
                  "`ratio_method` has to be `mean`, `sum`, `median`, `geometric.mean`, `slope` or `weighted.sum`"
                )
              }
            }
          }
        }
      }
    }
  },


  warning = function(w) {
    stop("something went wrong: ", w$message, call. = TRUE)
  })
}

#' @title Define and assign the base peak
#' @description `orbi_define_basepeak()` sets one isotopocule in the data frame as the base peak (ratio denominator)
#' @param dataset A tibble from a `IsoX` output. Needs to contain columns for `filename`, `compound`, `scan.no`, `isotopocule`, `ions.incremental`.
#' @param base_peak The isotopocule that gets assigned as base peak, i.e. the denominator to calculate ratios
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#'                      orbi_simplify_isox() %>%
#'                      orbi_define_basepeak(base_peak = "M0")
#'
#' @returns Input data frame plus two columns called `basepeak` and `basepeak.Ions`
#' @export
orbi_define_basepeak <- function(dataset, base_peak) {

  #basic checks
  if (missing(dataset))
    stop("no input for dataset supplied", call. = TRUE)

  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)

  if (missing(base_peak))
    stop(" no input for basepeak supplied", call. = TRUE)

  if (is.character(base_peak) == FALSE)
    stop("denominator must be a basepeak vector",  call. = TRUE)

  if (length(base_peak) > 1)
    stop("only one baspeak can be assigned",  call. = TRUE)


  # check that requires columns are present
  req_cols <- c("filename", "compound", "scan.no", "time.min", "isotopocule", "ions.incremental")

  missing_cols <- setdiff(req_cols, names(dataset))

  if (length(missing_cols) > 0) {
    paste0("Missing expected column(s): ", paste(missing_cols, collapse = ", ")) %>%
      stop(call. = FALSE)
  }


  # Annotation: Identify `base peak` for each scan

  tryCatch(

    df.sel <- dataset  %>% ungroup() %>%
      dplyr::select(
        .data$filename,
        .data$compound,
        .data$scan.no,
        .data$isotopocule,
        .data$ions.incremental
      ) %>%
      dplyr::group_by(.data$filename,
                      .data$compound,
                      .data$scan.no) %>%
      dplyr::filter(.data$isotopocule == base_peak) %>%
      dplyr::mutate(basepeak = factor(.data$isotopocule),
                    basepeak.Ions = .data$ions.incremental
      ) %>%
      dplyr::select(.data$filename,
                    .data$compound,
                    .data$scan.no,
                    .data$basepeak,
                    .data$basepeak.Ions) %>%
      as.data.frame(),

    warning = function(w) {
      stop("something went wrong: ", w$message, call. = TRUE)
    }
  )


  tryCatch(
    df.out <- merge(df.sel, dataset, all = TRUE),

    warning = function(w) {
      stop("something went wrong when merging data: ", w$message, call. = TRUE)
    }
  )


  tryCatch(
    df.out <- df.out %>% dplyr::filter(.data$isotopocule != base_peak) %>% droplevels(),

    warning = function(w) {
      stop("something went wrong removing the base peak isotopocule: ", w$message, call. = TRUE)
    }
  )

  return(df.out)
}


#' @title Generate the results table
#' @description Contains the logic to generate the results table
#' @param dataset A processed tibble produced from `IsoX` output
#' @param ratio_method Method for computing the ratio; passed to `orbi_calculate_ratio()`
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#'       orbi_simplify_isox() %>% orbi_define_basepeak(base_peak = "M0")  %>%
#'       orbi_calculate_results(ratio_method = "sum")
#'
#' @details **Description of the output columns:**
#'
#' * `basepeak`: Isotopocule used as denominator in ratio calculation.
#'
#' * `isotopocule`: Isotopocule used as numerator in ratio calculation.
#'
#' * `ratio_sem`: Standard error of the mean for the ratio
#'
#' * `number_of_scans`: Number of scans used for the final ratio calculation
#'
#' * `minutes_to_1e6_ions`: Time in minutes it would take to observe 1 million ions of the `isotopocule` used as numerator of the ratio calculation.
#'
#' * `shot_noise_permil`: Estimate of the shot noise (more correctly thermal noise) of the reported ratio in permil.
#'
#' * `ratio_relative_sem_permil`: Relative standard error of the reported ratio in permil
#'
#'
#' @details **Description of options for `ratio_method`:**
#'
#' @details Please note well: The formula used to calculate ion ratios matters! Do not simply use arithmetic mean.
#' The best option may depend on the type of data you are processing (e.g., MS1 versus M+1 fragmentation).
#'
#' * `mean`: arithmetic mean of ratios from individual scans.
#'
#' * `sum`: sum of all ions of the numerator across all scans divided by the sum of all ions observed for the denominator across all scans.
#'
#' * `geometric.mean`: geometric mean of ratios from individual scans.
#'
#' * `slope`: The ratio is calculated using the slope obtained from a linear regression model that is weighted by the `numerator x`, using `stats::lm(x ~ y + 0, weights = x)`.
#'
#' * `weighted.sum`: A derivative of the `sum` option. The weighing function ensures that each scan contributes equal weight to the ratio calculation,
#' i.e. scans with more ions in the Orbitrap do not contribute disproportionately to the total `sum` of `x` and `y` that is used to calculate `x/y`.
#'
#' @return Returns a results table containing `filename`, `compound`,  `basepeak`, `Isotopocule`, `Ratio`, `ratio_sem`, `ratio_relative_sem_permil`, `shot_noise_permil`, `No.of.Scans`, `minutes_to_1e6_ions`
#' @export
orbi_calculate_results <- function(dataset, ratio_method) {

  # basic checks
  if (missing(dataset))
    stop("no input for dataset supplied", call. = TRUE)

  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)

  if (missing(ratio_method))
    stop("no input for ratio_method supplied", call. = TRUE)

  ratio.options <- c("mean",
                     "sum",
                     "median",
                     "geometric.mean",
                     "slope",
                     "weighted.sum")

  if (!(ratio_method %in% ratio.options))
    stop(cat(
      "ratio_method must be on of the following: ",
      ratio.options,
      "\n",
      sep = " "
    ),
    call. = TRUE)


  # check that requires columns are present
  req_cols <-
    c(
      "filename",
      "compound",
      "scan.no",
      "time.min",
      "isotopocule",
      "ions.incremental",
      "basepeak"
    )

  missing_cols <- setdiff(req_cols, names(dataset))

  if (length(missing_cols) > 0) {
    paste0("Missing required column(s): ",
           paste(missing_cols, collapse = ", ")) %>%
      stop(call. = FALSE)
  }



 # optional groupings

  tryCatch({
    df.group <- dataset  %>% ungroup() %>%

      dplyr::group_by(.data$filename,
                      .data$compound,
                      .data$basepeak,
                      .data$isotopocule,
                      .add = TRUE)


    {if ("block" %in% names(dataset))

        #ensure block is defined as a factor

        df.group <-
        df.group  %>% mutate(block = as.factor(.data$block)) %>%
        dplyr::group_by(.data$block,
                        .add = TRUE)
      }

    {if ("segment" %in% names(dataset))

        #ensure segment is defined as a factor

        df.group <-
        df.group  %>% mutate(segment = as.factor(.data$segment)) %>%
        dplyr::group_by(.data$segment,
                        .add = TRUE)
    }

    {if ("injection" %in% names(dataset))

        #ensure injection is defined as a factor

        df.group <-
        df.group  %>% mutate(injection = as.factor(.data$injection)) %>%
        dplyr::group_by(.data$injection,
                        .add = TRUE)
    }
  },


  warning = function(w) {
    stop("something went wrong looking to add optional groupings: ",
         w$message,
         call. = TRUE)
  })


  tryCatch(
    df.stat <- df.group %>%

      dplyr::mutate(
        Ratio = orbi_calculate_ratio(.data$ions.incremental, .data$basepeak.Ions, ratio_method = ratio_method)
      ) %>% #THE ACTUAL RATIO CALCULATION!

      dplyr::mutate(ratio_sem = calculate_se(
        .data$ions.incremental / .data$basepeak.Ions
      )),

    #For simplicity use basic standard error for all options

    warning = function(w) {
      stop("something went wrong in the ratio calculations: ",
           w$message,
           call. = TRUE)
    }
  )



  tryCatch(

    df.stat <- df.stat %>% dplyr::mutate(
      number_of_scans = length(.data$Ratio),
      minutes_to_1e6_ions = (1E6 / sum(.data$ions.incremental)) * (max(.data$time.min) - min(.data$time.min)),
      #FIXME: could be better!
      shot_noise_permil = 1000 * (sqrt((
        sum(.data$ions.incremental) + sum(.data$basepeak.Ions)
      ) / (
        sum(.data$ions.incremental) * sum(.data$basepeak.Ions)
      ))),
      ratio_relative_sem_permil = 1000 * (.data$ratio_sem / .data$Ratio)
    ) %>%

      #Round values for output
      dplyr::mutate(
        Ratio = round(.data$Ratio, 8),
        ratio_sem = round(.data$ratio_sem, 8),
        shot_noise_permil = round(.data$shot_noise_permil, 3),
        ratio_relative_sem_permil = round(.data$ratio_relative_sem_permil, 3),
        minutes_to_1e6_ions = round(.data$minutes_to_1e6_ions, 2)
      ) %>%

      dplyr::select(
        -.data$ions.incremental,
        -.data$basepeak.Ions,
        -.data$time.min,
        -.data$scan.no,
        -.data$it.ms,
        -.data$tic
      ) %>%
      unique() %>%
      arrange(.data$filename, .data$compound, .data$isotopocule),

    warning = function(w) {
      stop("something went wrong in compiling the final results table: ",
           w$message,
           call. = TRUE)
    }
  )


  df.stat <- as.data.frame(df.stat)
  return(df.stat)
}
