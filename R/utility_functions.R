# Internal utility functions =============

# internal function to ensure dataset columns are factors (if they exist)
# will warn the user about the transformation
factorize_dataset <- function(dataset, cols = c()) {
  for (col in cols) {
    if (col %in% names(dataset) && !is.factor(dataset[[col]])) {
      sprintf("column `%s` was turned into a factor", col) |> message()
      dataset[[col]] <- factor_in_order(dataset[[col]])
    }
  }
  return(dataset)
}

# group if exists
group_if_exists <- function(dataset, cols, add = TRUE) {
  for (col in cols) {
    if (col %in% names(dataset))
      dataset <- dataset |> group_by(!!sym(col), .add = add)
  }
  return(dataset)
}

# group one dataset the same as another (use to restore original groupings)
group_by_same_groups <- function(target_dataset, source_dataset) {
  target_dataset |> dplyr::group_by(!!!dplyr::groups(source_dataset))
}

# internal function to wrap around expressions that should throw errors whenever anything unexpected happens
# error/warn can be text or function
try_catch_all <- function(expr, error, warn = error, newline = FALSE) {
  tryCatch(
    {{ expr }},
    error = function(p) {
      if(newline) cat("\n")
      if (is_function(error)) error(p)
      else abort(error, parent = p)
    },
    warning = function(p) {
      if(newline) cat("\n")
      if (is_function(warn)) warn(p)
      else abort(warn, parent = p)
    }
  )
}

# print out info start message
message_start <- function(...) {
  message_wrap(..., exdent = 3, appendLF = !interactive())
  return(Sys.time())
}

# print out info end message
message_finish <- function(..., start_time = NULL, pre = if (!interactive()) "..." else "") {
  end_time <- Sys.time()
  time_info <-
    if (!is.null(start_time)) sprintf(" in %.2f seconds.", end_time - start_time)
    else ""
  message_wrap(pre, ..., time_info, indent = if (interactive()) 0 else 3, exdent = 3)
}

# print out standalone info message
message_standalone <- function(..., start_time = NULL) {
  message_finish(..., start_time = start_time, pre = "")
}

# print out a message that wraps in non-interactive mode (e.g. in notebooks)
message_wrap <- function (..., appendLF = TRUE, width = if (!interactive()) options()$width - 2 else NA, indent = 0, exdent = 0) {
  if (is.na(width)) {
    message(..., appendLF = appendLF)
  } else {
    original <- paste0(..., collapse = "")
    original |>
      strwrap(width = width, indent = indent, exdent = exdent) |>
      paste(collapse = "\n") |>
      message(appendLF = appendLF)
  }
  invisible()
}


# Common utility functions to clean and annotate data ------------------------------------

#' @title Function replaced by `orbi_flag_satellite_peaks()`
#' @param ... parameters passed on to new function orbi_flag_satellite_peaks()
#' @export
orbi_filter_satellite_peaks <- function(...) {
  lifecycle::deprecate_warn("1.2.0", "orbi_filter_satellite_peaks()", "orbi_flag_satellite_peaks()", always = TRUE)
  orbi_flag_satellite_peaks(...) |>
    orbi_filter_flagged_data()
}

#' @title Flag minor satellite peaks
#' @description Flag minor signals (e.g., satellite peaks) that were reported by IsoX (filter them out with `orbi_filter_flagged_data()`).
#' @param dataset A data frame or tibble produced from IsoX data by `orbi_simplify_isox()`
#' @details The `orbi_filter_satellite_peaks()` function removes minor signals for an isotopocule that have been reported by IsoX.
#' These are often small `satellite peaks` generated by the Fourier transform.
#'
#' If there are signal of high intensity or very many signals, this can indicate that the m/z and tolerance setting used for processing .raw files with IsoX were incorrect.
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_flow.isox", package = "isoorbi")
#' df <-
#'   orbi_read_isox(file = fpath) |>
#'   orbi_simplify_isox() |>
#'   orbi_flag_satellite_peaks()
#'
#' @return A data frame with new column `is_satellite_peak` that flags satellite peaks.
#' @export
orbi_flag_satellite_peaks <- function(dataset) {

  # safety checks
  cols <- c("filename", "compound", "scan.no", "time.min", "isotopocule", "ions.incremental", "tic", "it.ms")
  stopifnot(
    "need a `dataset` data frame" = !missing(dataset) && is.data.frame(dataset),
    "`dataset` requires columns `filename`, `compound`, `scan.no`, `time.min`, `isotopocule`, `ions.incremental`, `tic` and `it.ms`" =
      all(cols %in% names(dataset))
  )

  # info
  start_time <-
    sprintf(
      "orbi_flag_satellite_peaks() is flagging minor signals (satellite peaks) from %d peaks... ",
      nrow(dataset)
    ) |>
    message_start()

  # calculation
  dataset <-
    try_catch_all(
      dataset |>
        dplyr::group_by(
          .data$filename,
          .data$compound,
          .data$scan.no,
          .data$isotopocule
        ) |>
        dplyr::mutate(is_satellite_peak = .data$ions.incremental < max(.data$ions.incremental)) |>
        dplyr::ungroup(),
      "something went wrong tying to flag satellite peaks: ",
      newline = TRUE
    )

  # info
  sat_peaks <- sum(dataset$is_satellite_peak)
  sprintf(
    "%d satellite peaks flagged (%.1f%%)",
    sat_peaks, 100 * sat_peaks/nrow(dataset)) |>
    message_finish(start_time = start_time)

  return(dataset)
}

#' @title Function replaced by `orbi_flag_weak_isotopocules()`
#' @param ... parameters passed on to new function orbi_flag_weak_isotopocules()
#' @export
orbi_filter_weak_isotopocules <- function(...) {
  lifecycle::deprecate_warn("1.2.0", "orbi_filter_weak_isotopocules()", "orbi_flag_weak_isotopocules()", always = TRUE)
  orbi_flag_weak_isotopocules(...) |>
    orbi_filter_flagged_data()
}

#' @title Flag weak isotopocules
#' @description The function `orbi_filter_weak_isotopocules()` flags isotopocules that are not consistently detected in most scans
#'
#' @param dataset A simplified IsoX data frame to be processed
#' @param min_percent A number between 0 and 90. Isotopocule must be observed in at least this percentage of scans (please note: the percentage is defined relative to the most commonly observed isotopocule of each compound)
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_flow.isox", package = "isoorbi")
#' df <- orbi_read_isox(file = fpath) |>
#'       orbi_simplify_isox() |>
#'       orbi_flag_weak_isotopocules(min_percent = 2)
#'
#' @details The input `dataset` is expected to have at least these 8 columns: `filename`, `scan.no`, `time.min`, `compound`, `isotopocule`, `ions.incremental`, `tic`, `it.ms`.
#'
#' @return A data frame with new column `is_weak_isotopocule` that flags satellite peaks.
#' @export
orbi_flag_weak_isotopocules <-
  function(dataset, min_percent) {

    # safety checks
    cols <- c("filename", "compound", "scan.no", "time.min", "isotopocule", "ions.incremental", "tic", "it.ms")
    stopifnot(
      "need a `dataset` data frame" = !missing(dataset) && is.data.frame(dataset),
      "`dataset` requires columns `filename`, `compound`, `scan.no`, `time.min`, `isotopocule`, `ions.incremental`, `tic` and `it.ms`" =
        all(cols %in% names(dataset)),
      "`min_percent` needs to be a single number" = !missing(min_percent) && is.numeric(min_percent) && length(min_percent) == 1L,
      "`min_percent` needs to be between 0 and 90" = min_percent >= 0 && min_percent <= 90
    )

    # ensure factors
    dataset <- dataset |> factorize_dataset("isotopocule")

    # optional groupings - FIXME: implement like in summarize_results?
    dataset_out <- dataset |>
      dplyr::ungroup() |>
      group_if_exists(c("filename", "block", "segment", "injection"))

    # info
    start_time <-
      sprintf(
        "orbi_filter_weak_isotopocules() is flagging isotopocules from data that are detected in less than %s%% of scans in %d data group(s) (based on '%s')... ",
        min_percent,  dplyr::n_groups(dataset_out), paste(dplyr::group_vars(dataset_out), collapse = "', '")) |>
      message_start()

    # minor peak removal
    dataset_out <-
      try_catch_all(
        dataset_out |>
          dplyr::mutate(max.scans = length(unique(.data$scan.no))) |>
          dplyr::group_by(.data$isotopocule, .add = TRUE) |>
          dplyr::mutate(obs.scans = length(unique(.data$scan.no))) |>
          dplyr::mutate(is_weak_isotopocule = .data$obs.scans < min_percent / 100 * .data$max.scans) |>
          dplyr::select(-"obs.scans", -"max.scans"),
      "something went wrong applying filter min_percent: ",
      newline = TRUE
    )

    # info
    remaining_levels <- dataset_out |> filter(!.data$is_weak_isotopocule) |> pull("isotopocule") |> droplevels() |> levels()
    flagged <- paste(setdiff(levels(dataset$isotopocule), remaining_levels), collapse = "', '")
    sprintf(
      "flagged %d isotopocules%s",
      length(levels(dataset$isotopocule)) - length(remaining_levels),
      if (nchar(flagged) > 0) sprintf(" (%s)", flagged) else "") |>
      message_finish(start_time = start_time)

    # return with restored groupings from original dataset
    return(dataset_out |> group_by_same_groups(dataset))
  }


#' @title Function replaced by `orbi_flag_outliers()`
#' @param ... parameters passed on to new function orbi_flag_outliers()
#' @param outlier_percent outlier_percent needs to be between 0 and 10, flags extreme scans based on TIC x injection time (i.e., ion intensity)
#' @export
orbi_filter_scan_intensity <- function(..., outlier_percent) {
  lifecycle::deprecate_warn("1.2.0", "orbi_filter_scan_intensity()", "orbi_flag_outliers()", always = TRUE)
  lifecycle::deprecate_warn("1.2.0", "orbi_filter_scan_intensity(outlier_percent)", details = "the argument `outlier_percent` has been superseded by `intensity_window`")
  orbi_flag_outliers(..., intensity_window = c(outlier_percent, 100 - outlier_percent)) |>
    orbi_filter_flagged_data()
}


#' @title Flag outlier scans
#' @description The function `orbi_flag_outliers()` flags outliers. Grouping is by columns `filename` and `compound`.
#' @param intensity_window flags extremely high and low intense scans based on TIC x injection time (i.e., ion intensity). Provide a vector with 2 numbers `c(x,y)` filtering the lowest x percent intensities and highest y percent intensities.
#' @param dataset Simplified IsoX dataset to have outliers flagged
#' @details Function is intended to flag scans that are outliers. TIC multiplied by injection time serves as an estimate for the number of ions in the Orbitrap.
#'
#' The input `dataset` is expected to have at least these 8 columns: `filename`, `scan.no`, `time.min`, `compound`, `isotopocule`, `ions.incremental`, `tic`, `it.ms`.
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_flow.isox", package = "isoorbi")
#' df <-
#'   orbi_read_isox(file = fpath) |>
#'   orbi_simplify_isox() |>
#'   orbi_flag_outliers(intensity_window = c(1,99))
#'
#' @return Filtered tibble
#' @export
orbi_flag_outliers <- function(dataset, intensity_window) {

  # safety checks
  cols <- c("filename", "compound", "scan.no", "tic", "it.ms")
  stopifnot(
    "need a `dataset` data frame" = !missing(dataset) && is.data.frame(dataset),
    "`dataset` requires columns `filename`, `compound`, `scan.no`, `tic` and `it.ms`" =
      all(cols %in% names(dataset)),
    "`intensity_window` needs to be a vector of two numbers (low and high filter) between 0 and 100" = !missing(intensity_window) && is.numeric(intensity_window) && length(intensity_window) == 2L && intensity_window[1] < intensity_window[2]
  )

  # optional groupings
  dataset_out <- dataset |>
    dplyr::ungroup() |>
    group_if_exists(c("filename", "block", "segment", "injection"))

  # info
  n_scans <- length(unique(dataset$scan.no))
  start_time <-
    sprintf(
      "orbi_filter_scan_intensity() is flagging the %s %% of scans with the lowest and above %s %% of scans with the highest intensities from %d scans in %d data group(s) (based on '%s')... ",
      intensity_window[1], intensity_window[2], n_scans,
      dplyr::n_groups(dataset_out), paste(dplyr::group_vars(dataset_out), collapse = "', '")) |>
    message_start()

  # calculation
  dataset_out <- try_catch_all(
    dataset_out |>
      dplyr::mutate(TICxIT = .data$tic * .data$it.ms) |>
      dplyr::mutate(
        is_outlier =
        .data$TICxIT <= stats::quantile(.data$TICxIT, intensity_window[1] / 100) |
          .data$TICxIT >= stats::quantile(.data$TICxIT, intensity_window[2] / 100)
      ) |>
      dplyr::select(-"TICxIT"),
    "something went wrong: "
  )

  # info
  n_scans_removed <- dataset_out |> dplyr::filter(.data$is_outlier) |> dplyr::pull(.data$scan.no) |> unique() |> length()
  sprintf(
    "flagged %d scans (%.1f%%)",
    n_scans_removed, n_scans_removed/n_scans * 100) |>
    message_finish(start_time = start_time)

  # return with restored groupings from original dataset
  return(dataset_out |> group_by_same_groups(dataset))
}


#' Filter out flagged data
#'
#' @param dataset a tibble with previously flagged data from `orbi_flat_satellite_peaks()`, `orbi_filter_weak_isotopocules()`, and/or `orbi_flag_outliers()`
#' @return the
#' @export
orbi_filter_flagged_data <- function(dataset) {

  # safety checks
  stopifnot(
    "need a `dataset` data frame" = !missing(dataset) && is.data.frame(dataset)
  )

  # original n
  nall <- nrow(dataset)
  nsat_peaks <- 0L
  nweak_isos <- 0L
  noutliers <- 0L

  # remove flagged
  start_time <- Sys.time()
  details <- c()
  if ("is_satellite_peak" %in% names(dataset)) {
    dataset <- dataset |> filter(!.data$is_satellite_peak)
    nsat_peaks <- nall - nrow(dataset)
    details <- c(details, sprintf("%d satellite peaks", nsat_peaks))
  }
  if ("is_weak_isotopocule" %in% names(dataset)) {
    dataset <- dataset |> filter(!.data$is_weak_isotopocule)
    nweak_isos <- nall - nsat_peaks - nrow(dataset)
    details <- c(details, sprintf("%d weak isotopocules", nweak_isos))
  }
  if ("is_outlier" %in% names(dataset)) {
    dataset <- dataset |> filter(!.data$is_outlier)
    noutliers <- nall - nsat_peaks - nweak_isos - nrow(dataset)
    details <- c(details, sprintf("%d outliers", noutliers))
  }

  # info
  sprintf(
    "orbi_filter_flagged_data() removed %d flagged records (%.1f%%)%s",
    nsat_peaks + nweak_isos + noutliers, 100 * (nsat_peaks + nweak_isos + noutliers)/nall,
    if(length(details) > 0) sprintf(" - %s", paste(details, collapse = ", ")) else ""
  ) |>
    message_standalone(start_time = start_time)

  # return
  return(dataset |> droplevels())
}


#' @title Define the denominator for ratio calculation
#'
#' @description `orbi_define_basepeak()` sets one isotopocule in the data frame as the base peak (ratio denominator)
#' @param dataset A tibble from a `IsoX` output. Needs to contain columns for `filename`, `compound`, `scan.no`, `isotopocule`, and `ions.incremental`.
#' @param basepeak_def The isotopocule that gets defined as base peak, i.e. the denominator to calculate ratios
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_flow.isox", package = "isoorbi")
#' df <- orbi_read_isox(file = fpath) |>
#'   orbi_simplify_isox() |>
#'   orbi_define_basepeak(basepeak_def = "M0")
#'
#' @returns Input data frame without the rows of the basepeak isotopocule and instead two new columns called `basepeak` and `basepeak_ions` holding the basepeak information
#' @export
orbi_define_basepeak <- function(dataset, basepeak_def) {

  # safety checks
  stopifnot(
    "need a `dataset` data frame" = !missing(dataset) && is.data.frame(dataset),
    "`dataset` requires columns `filename`, `compound`, `scan.no`, `isotopocule`, and `ions.incremental`" =
      all(c("filename", "compound", "scan.no", "isotopocule", "ions.incremental") %in% names(dataset)),
    "`basepeak_def` needs to be a single text value identifying the isotopocule to use as the basepeak" =
      !missing(basepeak_def) && rlang::is_scalar_character(basepeak_def),
    "`basepeak_def` is not an isotopocule in the dataset" = basepeak_def %in% levels(dataset$isotopocule)
  )

  # ensure factors
  dataset <- dataset |> factorize_dataset("isotopocule")

  # info message
  start_time <-
    sprintf(
      "orbi_define_basepeak() is setting the '%s' isotopocule as the ratio denominator... ",
      basepeak_def) |>
    message_start()

  # identify `basepeak` for each scan
  df.out <-
    try_catch_all({
      if ("is_satellite_peak" %in% names(dataset)) {
        dataset |>
          dplyr::group_by(.data$filename, .data$compound, .data$scan.no) |>
          dplyr::mutate(
            basepeak = !!basepeak_def,
            basepeak_ions = .data$ions.incremental[.data$isotopocule == !!basepeak_def & !.data$is_satellite_peak]
          ) |>
          dplyr::ungroup()
      } else {
        dataset |>
          dplyr::group_by(.data$filename, .data$compound, .data$scan.no) |>
          dplyr::mutate(
            basepeak = !!basepeak_def,
            basepeak_ions = .data$ions.incremental[.data$isotopocule == !!basepeak_def]
          ) |>
          dplyr::ungroup()
      }
    },
    function(p) {
      if (!is.null(p$parent) && grepl("`basepeak_ions` must be size", p$parent$message))
        sprintf("the %s isotopocule exists multiple times in some scans, make sure to run orbi_flag_satellite_peaks() first",
                basepeak_def) |>
        abort()
      else
        abort("something went wrong identifying the base peak for each scan", parent = p)
    },
    newline = TRUE
    )

  # remove basepeak from isotopocule list
  df.out <-
    try_catch_all(
      df.out |> dplyr::filter(.data$isotopocule != basepeak_def) |> droplevels(),
      "something went wrong removing the base peak isotopocule",
      newline = TRUE
    )

  # info
  sprintf(
    "base peak set for %d isotopocules ('%s')",
    length(levels(df.out$isotopocule)),
    paste(levels(df.out$isotopocule), collapse = "', '")) |>
    message_finish(start_time = start_time)

  # return
  return(df.out)
}

