# Common utility functions

#' @title Filter to remove minor satellite peaks
#' @description Remove minor signals (e.g., satellite peaks) that were reported by IsoX
#' @param dataset A data frame or tibble produced from IsoX data by `orbi_simplify_isox()`
#' @details The `orbi_filter_satellite_peaks()` function removes minor signals for an isotopocule that have been reported by IsoX.
#' These are often small `satellite peaks` generated by the Fourier transform.
#'
#' If there are signal of high intensity or very many signals, this can indicate that the m/z and tolerance setting used for processing .raw files with IsoX were incorrect.
#'
#'@examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#' orbi_simplify_isox() %>%
#' orbi_filter_satellite_peaks()
#'
#' @return Filtered data frame (tibble)
#' @export
orbi_filter_satellite_peaks <- function(dataset) {


  # safety checks
  if (missing(dataset))
    stop("no dataset supplied", call. = TRUE)
  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)
  if (ncol(dataset) < 8)
    stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
  if (nrow(dataset) < 1)
    stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)


  # check that requires columns are present
  req_cols <- c("filename", "compound", "scan.no", "time.min", "isotopocule", "ions.incremental", "tic", "it.ms")

  missing_cols <- setdiff(req_cols, names(dataset))

  if (length(missing_cols) > 0) {
    paste0("Missing required column(s): ", paste(missing_cols, collapse = ", ")) %>%
      stop(call. = FALSE)
  }

  message(
    paste0(
      "orbi_filter_satellite_peaks() is removing minor signals (e.g., satellite peaks) that were reported by IsoX..."
    )
  )


  tryCatch(
    df.out <- dataset %>% ungroup %>%
      dplyr::group_by(.data$filename,
                      .data$compound,
                      .data$scan.no,
                      .data$isotopocule) %>%
      dplyr::filter(.data$ions.incremental == max(.data$ions.incremental)),
    warning = function(w) {
      stop("something went wrong: ", w$message, call. = TRUE)
    }
  )

  return(df.out)
}



#' @title Filter to remove weak isotopocules
#' @description The function `orbi_filter_weak_isotopocules()` removes isotopocules that are not consistently detected in most scans
#'
#' @param dataset A simplified IsoX data frame to be processed
#' @param min_percent A number between 0 and 90. Isotopocule must be observed in at least this percentage of scans (please note: the percentage is defined relative to the most commonly observed isotopocule of the compound)
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#'                      orbi_simplify_isox() %>%
#'                      orbi_filter_weak_isotopocules(min_percent = 2)
#'
#' @details The input `dataset` is expected to have at least these 8 columns: `filename`, `scan.no`, `time.min`, `compound`, `isotopocule`, `ions.incremental`, `tic`, `it.ms`.
#'
#' @return Filtered tibble
#' @export
orbi_filter_weak_isotopocules <-
  function(dataset, min_percent) {


    # safety checks
    if (missing(dataset))
      stop("no dataset supplied", call. = TRUE)
    if (is.data.frame(dataset) == FALSE)
      stop("dataset must be a data frame",  call. = TRUE)
    if (ncol(dataset) < 8)
      stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
    if (nrow(dataset) < 1)
      stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)

    if (missing(min_percent))
      stop("value for min_percent missing", call. = TRUE)

    if (!(is.numeric(min_percent)))
      stop("min_percent needs to be a number", call. = TRUE)
    if (!(min_percent >= 0 && min_percent <=90))
      stop("min_percent needs to be between 0 and 90 ", call. = TRUE)


    # check that requires columns are present
    req_cols <- c("filename", "compound", "scan.no", "time.min", "isotopocule", "ions.incremental", "tic", "it.ms")

    missing_cols <- setdiff(req_cols, names(dataset))

    if (length(missing_cols) > 0) {
      paste0("Missing required column(s): ", paste(missing_cols, collapse = ", ")) %>%
        stop(call. = FALSE)
    }

    message(paste0(
      "orbi_filter_weak_isotopocules() is remove isotopocules ",
      # deparse(substitute(dataset)), #FIXME: How to print name of datatframe object?
      "that are detected in less than ",
      min_percent,
      "% of scans (in each grouping)...")
    )


    #Optional groupings

    tryCatch(

      {


        df.group <- dataset  %>% dplyr::ungroup() %>%
          dplyr::group_by(.data$filename,
                          .data$compound, .add = TRUE)


        {if ("block" %in% names(dataset))

            #ensure block is defined as a factor

            df.group <-
            df.group  %>% mutate(block = as.factor(.data$block)) %>%
            dplyr::group_by(.data$block,
                            .add = TRUE)
          }

        {if ("segment" %in% names(dataset))

            #ensure segment is defined as a factor

            df.group <-
            df.group  %>% mutate(segment = as.factor(.data$segment)) %>%
            dplyr::group_by(.data$segment,
                            .add = TRUE)
        }

        {if ("injection" %in% names(dataset))

            #ensure injection is defined as a factor

            df.group <-
            df.group  %>% mutate(injection = as.factor(.data$injection)) %>%
            dplyr::group_by(.data$injection,
                            .add = TRUE)
        }
      },


      warning = function(w) {
        stop("something went wrong looking to add optional groupings: ",
             w$message,
             call. = TRUE)
      }
    )


    tryCatch(

      remove.df <- df.group %>%
          dplyr::mutate(max.scans = length(unique(.data$scan.no))) %>%
          dplyr::group_by(.data$isotopocule, .add = TRUE) %>%
          dplyr::mutate(obs.scans = length(unique(.data$scan.no))) %>%
          dplyr::filter(.data$obs.scans < min_percent / 100 * .data$max.scans) %>%
          dplyr::select(-.data$obs.scans,-.data$max.scans) %>% droplevels() %>% as.data.frame(),
        warning = function(w) {
          stop("something went wrong applying filter min_percent: ", w$message, call. = TRUE)

      }
    )


    tryCatch(
      df.out <-
        dplyr::anti_join(
          dataset,
          remove.df,
          by = c(
            "filename",
            "scan.no",
            "time.min",
            "compound",
            "isotopocule",
            "ions.incremental",
            "tic",
            "it.ms"
          )
        ),
             warning = function(w) {
               stop("something went wrong: ", w$message, call. = TRUE)
             }
    )

    return(df.out)

  }


#' @title Filter to remove extreme scans
#' @description The function `orbi_filter_scan_intensity()` removes extremely high and low intense scans based on TIC x injection time (i.e., ion intensity)
#' @param dataset Simplified IsoX dataset to have `TICxIT` outliers removed
#' @param truncate_extreme A number between 0 and 10. Remove this percentage of scans based on TIC multiplied by injection time.
#' @details Function is intended to remove scans that are outliers. TIC multiplied by injection time serves as an estimate for the number of ions in the Orbitrap.
#'
#' The filter is a basic truncation that removes `x %` of scans with the largest **and** `x %` of scans with the smallest ion estimates. Grouping is by columns `filename` and `compound`.
#'
#' The input `dataset` is expected to have at least these 8 columns: `filename`, `scan.no`, `time.min`, `compound`, `isotopocule`, `ions.incremental`, `tic`, `it.ms`.
#'
#'@examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#' orbi_simplify_isox() %>%
#' orbi_filter_scan_intensity(truncate_extreme = 1)
#'
#' @return Filtered tibble
#' @export
orbi_filter_scan_intensity <- function(dataset, truncate_extreme) {


  # safety checks
  if (missing(dataset))
    stop("no dataset supplied", call. = TRUE)
  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)
  if (ncol(dataset) < 8)
    stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
  if (nrow(dataset) < 1)
    stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)

  if (missing(truncate_extreme))
    stop("value for truncate_extreme missing", call. = TRUE)

  if (!(is.numeric(truncate_extreme)))
    stop("truncate_extreme needs to be a number", call. = TRUE)
  if (!(truncate_extreme >= 0 && truncate_extreme <=10))
    stop("truncate_extremet needs to be between 0 and 10 ", call. = TRUE)



  # check that requires columns are present
  req_cols <- c("filename", "compound", "scan.no", "time.min", "isotopocule", "ions.incremental", "tic", "it.ms")

  missing_cols <- setdiff(req_cols, names(dataset))

  if (length(missing_cols) > 0) {
    paste0("Missing required column(s): ", paste(missing_cols, collapse = ", ")) %>%
      stop(call. = FALSE)
  }

  message(paste0(
    "orbi_filter_scan_intensity() is removing extremely high and low intense scans.",
    #deparse(substitute(dataset)), # FIXME: How to print name of data frame object?
    " A total of ", 2* truncate_extreme, "% of the scans will be removed...")
  )

  #Optional groupings

  tryCatch(

    {df.group <- dataset  %>% dplyr::ungroup() %>%
        dplyr::group_by(.data$filename,
                        .data$compound, .add = TRUE)


      {if ("block" %in% names(dataset))

          #ensure block is defined as a factor

          df.group <-
          df.group  %>% mutate(block = as.factor(.data$block)) %>%
          dplyr::group_by(.data$block,
                          .add = TRUE)
        }

      {if ("segment" %in% names(dataset))

          #ensure segment is defined as a factor

          df.group <-
          df.group  %>% mutate(segment = as.factor(.data$segment)) %>%
          dplyr::group_by(.data$segment,
                          .add = TRUE)
      }

      {if ("injection" %in% names(dataset))

          #ensure injection is defined as a factor

          df.group <-
          df.group  %>% mutate(injection = as.factor(.data$injection)) %>%
          dplyr::group_by(.data$injection,
                          .add = TRUE)
      }
    },


    warning = function(w) {
      stop("something went wrong looking to add optional groupings: ",
           w$message,
           call. = TRUE)
    }
  )

  tryCatch(  df.out <- df.group %>%
               dplyr::mutate(TICxIT = .data$tic * .data$it.ms) %>%
               dplyr::filter(
                 .data$TICxIT > stats::quantile(.data$TICxIT, truncate_extreme / 100) &
                 .data$TICxIT < stats::quantile(.data$TICxIT, 1 - truncate_extreme / 100)
               ) %>%
               dplyr::select(-.data$TICxIT),
    warning = function(w) {
      stop("something went wrong: ", w$message, call. = TRUE)
    }
  )

  return(df.out)
}


# Functions to calculate stats --------------------------------------------

# @title Internal function to calculate standard error
# @description The fuction `calculate_se()` computes a regular standard error
# @keywords internal
# @param x A numeric vector used to calculate a standard error
# @return The calculated standard error

calculate_se <- function(x) {

  # safety checks
  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)


  tryCatch(
    stats::sd(x) / sqrt(length(x)),
    warning = function(w) {
      stop("something went wrong calculating the standard error: ", w$message, call. = TRUE)
    }
  )

}

# @title Internal function to calculate geometric mean
# @description  The function `calculate_gmean()` is used to calculate geometric means
# @keywords internal
# @param x A numeric vector used to calculate the geometric mean
# @return The calculated geometric mean

calculate_gmean <- function(x) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  tryCatch(
    exp(mean(log(x))),
    warning = function(w) {
      stop("something went wrong calculating the geometic mean: ", w$message, call. = TRUE)
    }
  )


}


# @title Internal function to calculate standard deviation (geometric)
# @description  The function `calculate_gsd()` is used to calculate geometric standard deviations
# @keywords internal
# @param x A numeric values used to calculate the geometric standard deviation
# @return The calculated geometric standard deviation
calculate_gsd <- function(x) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  tryCatch(
    exp(mean(log(x)) + stats::sd(log(x))) - exp(mean(log(x))),
    warning = function(w) {
      stop("something went wrong calculating geometric standard deviaton: ", w$message, call. = TRUE)
    }
  )

}

# @title Internal function to calculate standard error (geometric)
# @description  The function `calculate_gse()` is used to calculate geometric standard errors
# @keywords internal
# @param x A vector of values used to calculate geometric standard errors
# @return The calculated geometric standard error
calculate_gse <- function(x) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  tryCatch(
    (exp(mean(log(x)) + stats::sd(log(x))) - exp(mean(log(x)))) / sqrt(length(x)),
    warning = function(w) {
      stop("something went wrong calculating the geometric standard error: ", w$message, call. = TRUE)
    }
  )

}

# @title Internal function for ratio_method `slope`
# @description  The function `calculate_slope()` is used to estimate the slope of x, y values used in a ratio
# @keywords internal
# @param x Vector of values used as ratio nominator
# @param y Vector of values used as ratio denominator
# @details The slope is calculated from a linear regression model that is weighted by the numerator x, using `stats::lm(x ~ y + 0, weights = x)`
# @return The calculated slope, an estimate of the ratio x/y
calculate_slope <- function(x, y) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  if (missing(y))
    stop("input vector for y supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  #basic checks
  if (!(is.vector(y)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(y)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(y) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  if (length(x) != length(y))
    stop("Length of x and y need to be equal", call. = TRUE)

  tryCatch(
    model <- stats::lm(x ~ y + 0, weights = x), #Note order of x and y to get correct slope!

    warning = function(w) {
      stop("something went wrong calculating the ratio as slope using a linear model: ", w$message, call. = TRUE)
    }
  )

  sl <- model$coefficients[[1]]
  return(sl)
}

# @title Internal function for ratio_method `weighted_sum`
# @description The function `calculate_weighted_sum()` is used to calculate ratios by weighted sums of x and y values
# @keywords internal
# @param x A vector of values used as ratio nominator
# @param y A vector of values used as ratio denominator
# @details The weighing function ensures that each scan contributes equal weight to the ratio calculation,
# i.e. scans with more ions in the Orbitrap do not contribute disproportionally to the total sum of x and y that is used to calculate x/y.
# @return The calculated ratio x/y
calculate_weighted_sum <- function(x, y) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  if (missing(y))
    stop("input vector for y supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  #basic checks
  if (!(is.vector(y)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(y)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(y) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  if (length(x) != length(y))
    stop("Length of x and y need to be equal", call. = TRUE)


  df <- cbind(x, y)

  avg.ions <- (sum(df[, 1]) + sum(df[, 2])) / length(df[, 1])

  scan.ions <- (df[, 1] + df[, 2])

  weighted.x <- avg.ions / scan.ions  * as.numeric(df[, 1])
  weighted.y <- avg.ions / scan.ions  * as.numeric(df[, 2])

  tryCatch(
    ratio <- sum(weighted.x) / sum(weighted.y), #Note order of x and y to get correct slope!

    warning = function(w) {
      stop("something went wrong calculating the ratio from weighted sums: ", w$message, call. = TRUE)
    }
  )

  return(ratio)
}

#' @title Calculate isotopocule ratios
#' @description Ratio calculation between isotopocules and base peak defined by `orbi_define_basepeak()`.
#'
#' Please note well: The formula used to calculate ion ratios matters! Do not simply use arithmetic mean.
#' The best option may depend on the type of data you are processing (e.g., MS1 versus M+1 fragmentation).
#'
#'
#' @param numerator Column(s) used as numerator; contains ion counts
#' @param denominator Column used as denominator; contains ion counts
#' @param ratio_method Method for computing the ratio
#'
#'
#' @details **Description of options for `ratio_method`:**
#'
#' * `mean`: arithmetic mean of ratios from individual scans.
#'
#' * `sum`: sum of all ions of the numerator across all scans divided by the sum of all ions observed for the denominator across all scans.
#'
#' * `geometric_mean`: geometric mean of ratios from individual scans.
#'
#' * `slope`: The ratio is calculated using the slope obtained from a linear regression model that is weighted by the `numerator x`, using `stats::lm(x ~ y + 0, weights = x)`.
#'
#' * `weighted_sum`: A derivative of the `sum` option. The weighing function ensures that each scan contributes equal weight to the ratio calculation,
#' i.e. scans with more ions in the Orbitrap do not contribute disproportionately to the total `sum` of `x` and `y` that is used to calculate `x/y`.
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#'                      orbi_simplify_isox() %>%
#'                      orbi_define_basepeak(base_peak = "M0")
#' ratio <- orbi_calculate_ratios(numerator = df$ions.incremental,
#'                           denominator = df$basepeak_ions,
#'                          ratio_method =  "sum")
#'
#' @return Calculated ratio between isotopocules defined as numerator(s) and denominator, using one of the ratio methods.
#' @export

orbi_calculate_ratios <- function(numerator,
                                 denominator,
                                 ratio_method = c("mean",
                                                  "sum",
                                                  "median",
                                                  "geometric_mean",
                                                  "slope",
                                                  "weighted_sum")) {


  if (missing(numerator))
    stop("no input for numerator supplied", call. = TRUE)

  if (is.numeric(numerator) == FALSE)
    stop("numerator must be a numeric vector",  call. = TRUE)

  if (missing(denominator))
    stop(" no input for denominator supplied", call. = TRUE)

  if (is.numeric(denominator) == FALSE)
    stop("denominator must be a numeric vector",  call. = TRUE)


  tryCatch({ o <-  {
     if (ratio_method == "mean") {
       base::mean(numerator / denominator)
     } else if (ratio_method == "slope") {
       calculate_slope(numerator, denominator)
     } else if (ratio_method == "sum") {
       base::sum(numerator) / sum(denominator)
     } else if (ratio_method == "geometric_mean") {
       calculate_gmean(numerator / denominator)
     } else if (ratio_method == "weighted_sum") {
       calculate_weighted_sum(numerator, denominator)
     } else if (ratio_method == "median") {
       stats::median(numerator / denominator)
     } else{
       stop(
         "`ratio_method` has to be `mean`, `sum`, `median`, `geometric_mean`, `slope` or `weighted_sum`",
         call. = FALSE
       )
     }
   }

   warning = function(w) {
     stop("something went wrong calculating ratios:", w$message, call. = TRUE)

  }
  })

  return(o)

}


#' @title Define and assign the base peak
#' @description `orbi_define_basepeak()` sets one isotopocule in the data frame as the base peak (ratio denominator)
#' @param dataset A tibble from a `IsoX` output. Needs to contain columns for `filename`, `compound`, `scan.no`, `isotopocule`, `ions.incremental`.
#' @param base_peak The isotopocule that gets assigned as base peak, i.e. the denominator to calculate ratios
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#'                      orbi_simplify_isox() %>%
#'                      orbi_define_basepeak(base_peak = "M0")
#'
#' @returns Input data frame plus two columns called `basepeak` and `basepeak_ions`
#' @export
orbi_define_basepeak <- function(dataset, base_peak) {


  #basic checks
  if (missing(dataset))
    stop("no input for dataset supplied", call. = TRUE)

  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)

  if (missing(base_peak))
    stop(" no input for basepeak supplied", call. = TRUE)

  if (is.character(base_peak) == FALSE)
    stop("denominator must be a basepeak vector",  call. = TRUE)

  if (length(base_peak) > 1)
    stop("only one baspeak can be assigned",  call. = TRUE)


  # check that requires columns are present
  req_cols <- c("filename", "compound", "scan.no", "time.min", "isotopocule", "ions.incremental")

  missing_cols <- setdiff(req_cols, names(dataset))

  if (length(missing_cols) > 0) {
    paste0("Missing expected column(s): ", paste(missing_cols, collapse = ", ")) %>%
      stop(call. = FALSE)
  }


  message(paste0("orbi_define_basepeak() is setting the ",
                 base_peak,
                 " isotopocule as the ratio denominator...")
          )


  # Annotation: Identify `base peak` for each scan

  tryCatch(

    df.sel <- dataset  %>% dplyr::ungroup() %>%
      dplyr::select(
        .data$filename,
        .data$compound,
        .data$scan.no,
        .data$isotopocule,
        .data$ions.incremental
      ) %>%
      dplyr::group_by(.data$filename,
                      .data$compound,
                      .data$scan.no) %>%
      dplyr::filter(.data$isotopocule == base_peak) %>%
      dplyr::mutate(basepeak = factor(.data$isotopocule),
                    basepeak_ions = .data$ions.incremental
      ) %>%
      dplyr::select(.data$filename,
                    .data$compound,
                    .data$scan.no,
                    .data$basepeak,
                    .data$basepeak_ions),

    warning = function(w) {
      stop("something went wrong identifying the base peak for each scan: ", w$message, call. = TRUE)
    }
  )


  tryCatch(
    df.out <- dplyr::full_join(df.sel, dataset, by = c("filename", "compound", "scan.no")), #FIXME: carefully test this is correct

    warning = function(w) {
      stop("something went wrong when merging data: ", w$message, call. = TRUE)
    }
  )


  tryCatch(
    df.out <- df.out %>% dplyr::filter(.data$isotopocule != base_peak) %>% droplevels(),

    warning = function(w) {
      stop("something went wrong removing the base peak isotopocule: ", w$message, call. = TRUE)
    }
  )

  return(df.out)
}


#' @title Generate the results table
#' @description Contains the logic to generate the results table. See the \code{\link{orbi_calculate_ratios}} function for details on the different options for the \code{ratio_method} parameter.
#' @param dataset A processed tibble produced from `IsoX` output
#' @inheritParams orbi_calculate_ratios
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#'       orbi_simplify_isox() %>% orbi_define_basepeak(base_peak = "M0")  %>%
#'       orbi_summarize_results(ratio_method = "sum")
#'
#' @details **Description of the output columns:**
#'
#' * `basepeak`: Isotopocule used as denominator in ratio calculation.
#'
#' * `isotopocule`: Isotopocule used as numerator in ratio calculation.
#'
#' * `ratio_sem`: Standard error of the mean for the ratio
#'
#' * `number_of_scans`: Number of scans used for the final ratio calculation
#'
#' * `minutes_to_1e6_ions`: Time in minutes it would take to observe 1 million ions of the `isotopocule` used as numerator of the ratio calculation.
#'
#' * `shot_noise_permil`: Estimate of the shot noise (more correctly thermal noise) of the reported ratio in permil.
#'
#' * `ratio_relative_sem_permil`: Relative standard error of the reported ratio in permil
#'
#'
#' @return Returns a results table containing `filename`, `compound`,  `basepeak`, `Isotopocule`, `ratio`, `ratio_sem`, `ratio_relative_sem_permil`, `shot_noise_permil`, `No.of.Scans`, `minutes_to_1e6_ions`
#' @export
orbi_summarize_results <- function(dataset, ratio_method) {

  # basic checks
  if (missing(dataset))
    stop("no input for dataset supplied", call. = TRUE)

  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)

  if (missing(ratio_method))
    stop("no input for ratio_method supplied", call. = TRUE)

  ratio.options <- c("mean",
                     "sum",
                     "median",
                     "geometric_mean",
                     "slope",
                     "weighted_sum")

  if (!(ratio_method %in% ratio.options))
    stop(cat(
      "ratio_method must be on of the following: ",
      ratio.options,
      "\n",
      sep = " "
    ),
    call. = TRUE)


  # check that requires columns are present
  req_cols <-
    c(
      "filename",
      "compound",
      "scan.no",
      "time.min",
      "isotopocule",
      "ions.incremental",
      "basepeak"
    )

  missing_cols <- setdiff(req_cols, names(dataset))

  if (length(missing_cols) > 0) {
    paste0("Missing required column(s): ",
           paste(missing_cols, collapse = ", ")) %>%
      stop(call. = FALSE)
  }



 # determine groupings

  all_groups <- c("filename", "compound", "basepeak", "isotopocule")
  if ("block" %in% names(dataset))
    all_groups <- c(all_groups, "block")
  if ("segment" %in% names(dataset))
    all_groups <- c(all_groups, "segment")

  sprintf("orbi_summarize_results() is grouping the data (by %s) and summarizing ratios using the '%s' method...",
          paste(all_groups, collapse = ", "), ratio_method) %>%
    message()

  # execute grouping
  df.group <- dataset %>%
    dplyr::group_by(!!!lapply(x, rlang::sym))

  # run calculations
  df.out <- df.group %>%
    summarize(
      ratio = orbi_calculate_ratios(.data$ions.incremental, .data$basepeak_ions, ratio_method = ratio_method),
      ratio_sem = calculate_se(.data$ions.incremental / .data$basepeak_ions),
      ...,
      .groups = "drop"
    )


  tryCatch({
    df.group <- dataset  %>% dplyr::ungroup() %>%

      dplyr::group_by(.data$filename,
                      .data$compound,
                      .data$basepeak,
                      .data$isotopocule,
                      .add = TRUE)
    message(
      paste0(
        "orbi_summarize_results() is grouping dataset ",
        #deparse(substitute(dataset)), #FIXME: How to print name of data frame object?
        "by columns: filename, compound, basepeak, isotopocule"
      )
    )


    {if ("block" %in% names(dataset)) {

      #ensure block is defined as a factor

      df.group <-
        df.group  %>% mutate(block = as.factor(.data$block)) %>%
        dplyr::group_by(.data$block,
                        .add = TRUE)

      message(paste0(
        "orbi_summarize_results() is adding a grouping",
        # deparse(substitute(dataset)), #FIXME: add name of data frame object?
        ": block"
      ))
    }

      }

    {if ("segment" %in% names(dataset)) {

        #ensure segment is defined as a factor

        df.group <-
        df.group  %>% mutate(segment = as.factor(.data$segment)) %>%
        dplyr::group_by(.data$segment,
                        .add = TRUE)

      message(paste0(
        "orbi_summarize_results() is adding a grouping",
        #deparse(substitute(dataset)), #FIXME: add name of data frame object?
        ": segment"
      ))
    }

    }

    {if ("injection" %in% names(dataset)) {
      #ensure injection is defined as a factor

      df.group <-
        df.group  %>% mutate(injection = as.factor(.data$injection)) %>%
        dplyr::group_by(.data$injection,
                        .add = TRUE)

      message(paste0(
        "orbi_summarize_results() is adding a grouping",
        #deparse(substitute(dataset)), #FIXME: add name of data frame object?
        ": injection"
      ))

    }

    }
  },


  warning = function(w) {
    stop("something went wrong looking to add optional groupings: ",
         w$message,
         call. = TRUE)
  })



  message(
    paste0(
      "orbi_calculate_ratios() is calculating ratios, using the ratio_method: ",
      ratio_method
    )
  )


  tryCatch(
    df.stat <- df.group %>%

      dplyr::mutate(
        ratio = orbi_calculate_ratios(.data$ions.incremental, .data$basepeak_ions, ratio_method = ratio_method)
      ) %>% #THE ACTUAL RATIO CALCULATION!

      dplyr::mutate(ratio_sem = calculate_se(
        .data$ions.incremental / .data$basepeak_ions
      )),

    #For simplicity use basic standard error for all options

    warning = function(w) {
      stop("something went wrong in the ratio calculations: ",
           w$message,
           call. = TRUE)
    }
  )

  message(paste0(
    "orbi_summarize_results() is summarizing ratios for the results table..."
  ))


  tryCatch(

    df.stat <- df.stat %>% dplyr::mutate(
      number_of_scans = length(.data$ratio),
      minutes_to_1e6_ions = (1E6 / sum(.data$ions.incremental)) * (max(.data$time.min) - min(.data$time.min)),
      #FIXME: could be better!
      shot_noise_permil = 1000 * (sqrt((
        sum(.data$ions.incremental) + sum(.data$basepeak_ions)
      ) / (
        sum(.data$ions.incremental) * sum(.data$basepeak_ions)
      ))),
      ratio_relative_sem_permil = 1000 * (.data$ratio_sem / .data$ratio)
    ) %>%

      #Round values for output
      dplyr::mutate(
        ratio = round(.data$ratio, 8),
        ratio_sem = round(.data$ratio_sem, 8),
        shot_noise_permil = round(.data$shot_noise_permil, 3),
        ratio_relative_sem_permil = round(.data$ratio_relative_sem_permil, 3),
        minutes_to_1e6_ions = round(.data$minutes_to_1e6_ions, 2)
      ) %>%

      dplyr::select(
        -.data$ions.incremental,
        -.data$basepeak_ions,
        -.data$time.min,
        -.data$scan.no,
        -.data$it.ms,
        -.data$tic
      ) %>%
      unique() %>%
      arrange(.data$filename, .data$compound, .data$isotopocule),

    warning = function(w) {
      stop("something went wrong in compiling the final results table: ",
           w$message,
           call. = TRUE)
    }
  )


  df.stat <- as.data.frame(df.stat)
  return(df.stat)
}
