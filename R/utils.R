# Common utility functions

#' @title Filter weak isotopocules
#' @description Remove isotopocules that are not consistently detected across scans
#'
#' @param dataset Simplified IsoX data to be processed
#' @param min_percent Set threshold. Isotopocule must be observed in at least  x percent of scans
#'
#' @return Filtered tibble
#' @export
orbi_filter_weak <-
  function(dataset, min_percent) {

    # safety checks
    if (missing(dataset))
      stop("no dataset supplied", call. = TRUE)
    if (is.data.frame(dataset) == FALSE)
      stop("dataset must be a data frame",  call. = TRUE)
    if (ncol(dataset) < 8)
      stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
    if (nrow(dataset) < 1)
      stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)

    if (missing(min_percent))
      stop("value for min_percent missing", call. = TRUE)

    if (!(is.numeric(min_percent)))
      stop("min_percent needs to be a number", call. = TRUE)
    if (!(min_percent >= 0 && min_percent <=90))
      stop("min_percent needs to be between 0 and 90 ", call. = TRUE)


    # check that requires columns are present
    if (!(c("filename") %in% colnames(dataset)))
      stop("dataset does not contain column filename", call. = TRUE)
    if (!(c("scan.no") %in% colnames(dataset)))
      stop("dataset does not contain column scan.no", call. = TRUE)
    if (!(c("time.min") %in% colnames(dataset)))
      stop("dataset does not contain column time.min", call. = TRUE)
    if (!(c("compound") %in% colnames(dataset)))
      stop("dataset does not contain column compound", call. = TRUE)
    if (!(c("isotopolog") %in% colnames(dataset)))
      stop("dataset does not contain column isotopolog", call. = TRUE)
    if (!(c("ions.incremental") %in% colnames(dataset)))
      stop("dataset does not contain column ions.incrementalo", call. = TRUE)
    if (!(c("tic") %in% colnames(dataset)))
      stop("dataset does not contain column tic", call. = TRUE)
    if (!(c("it.ms") %in% colnames(dataset)))
      stop("dataset does not contain column it.ms",  call. = TRUE)

    remove.df <- dataset %>%
      dplyr::group_by(.data$filename) %>%
      dplyr::mutate(n.scans = max(.data$scan.no) - min(.data$scan.no)) %>% #FIXME: implement a more general solution here
      dplyr::group_by(.data$filename, .data$compound, .data$isotopolog) %>%
      dplyr::mutate(i.scans = length(.data$scan.no)) %>%
      dplyr::filter(.data$i.scans < min_percent / 100 * .data$n.scans) %>% # => update selection in GUI?, add message? used previously `input$rare`
      dplyr::select(-.data$n.scans, -.data$i.scans) %>% droplevels() %>% as.data.frame()


    df.out <-
      anti_join(
        dataset,
        remove.df,
        by = c(
          "filename",
          "scan.no",
          "time.min",
          "compound",
          "isotopolog",
          "ions.incremental",
          "tic",
          "it.ms"
        )
      )

    return(df.out)

  }



#
#' @title Filter satellite peaks
#' @description Remove minor signals (e.g., satellite peaks) that were reported by IsoX
#' @param df A data frame or tibble produced from IsoX data by orbi_simplify_isox()
#' @details The orbi_filter_satellitePeaks() function removes minor signals for an isotopocule that have been reported by IsoX.
#' These are often small 'satellite peaks' generated by the Fourier transform.
#' If there are signal of high intensity or very many signals, this can indicate that the m/z and tolerance setting used for processing .raw files with IsoX were incorrect.
#' @return Filtered tibble
#' @export
orbi_filter_satellitePeaks <- function(dataset) {

  # safety checks
  if (missing(dataset))
    stop("no dataset supplied", call. = TRUE)
  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)
  if (ncol(dataset) < 8)
    stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
  if (nrow(dataset) < 1)
    stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)




  # check that requires columns are present
  if (!(c("filename") %in% colnames(dataset)))
    stop("dataset does not contain column filename", call. = TRUE)
  if (!(c("scan.no") %in% colnames(dataset)))
    stop("dataset does not contain column scan.no", call. = TRUE)
  if (!(c("time.min") %in% colnames(dataset)))
    stop("dataset does not contain column time.min", call. = TRUE)
  if (!(c("compound") %in% colnames(dataset)))
    stop("dataset does not contain column compound", call. = TRUE)
  if (!(c("isotopolog") %in% colnames(dataset)))
    stop("dataset does not contain column isotopolog", call. = TRUE)
  if (!(c("ions.incremental") %in% colnames(dataset)))
    stop("dataset does not contain column ions.incrementalo", call. = TRUE)
  if (!(c("tic") %in% colnames(dataset)))
    stop("dataset does not contain column tic", call. = TRUE)
  if (!(c("it.ms") %in% colnames(dataset)))
    stop("dataset does not contain column it.ms",  call. = TRUE)

  df.out <- dataset %>%
    dplyr::group_by(.data$filename,
                    .data$compound,
                    .data$scan.no,
                    .data$isotopolog) %>%
    dplyr::filter(.data$ions.incremental == max(.data$ions.incremental))

  return(df.out)
}


#' @title Filter by TIC x Injection Time
#' @description Remove extreme scans based on TIC x Injection time
#' @param dataset Simplified IsoX file to have 'ticxit' outliers removed
#' @param truncate_extreme Remove extreme scans (percentage) based on TIC x Injection time. A number between 0 and 10.
#' @details The orbi_filter_TICxIT() function removes scans that are outliers. TIC x Injection time serves as an estimate for the number of ions in the Orbitrap. The filter is a basic truncation that removed x % of scans with maximal or minimal ion estimates.
#' @return Filtered data frame
#' @export
orbi_filter_TICxIT <- function(dataset, truncate_extreme) {

  # safety checks
  if (missing(dataset))
    stop("no dataset supplied", call. = TRUE)
  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)
  if (ncol(dataset) < 8)
    stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
  if (nrow(dataset) < 1)
    stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)

  if (missing(truncate_extreme))
    stop("value for truncate_extreme missing", call. = TRUE)

  if (!(is.numeric(truncate_extreme)))
    stop("truncate_extreme needs to be a number", call. = TRUE)
  if (!(truncate_extreme >= 0 && truncate_extreme <=10))
    stop("truncate_extremet needs to be between 0 and 10 ", call. = TRUE)



  # check that requires columns are present
  if (!(c("filename") %in% colnames(dataset)))
    stop("dataset does not contain column filename", call. = TRUE)
  if (!(c("scan.no") %in% colnames(dataset)))
    stop("dataset does not contain column scan.no", call. = TRUE)
  if (!(c("time.min") %in% colnames(dataset)))
    stop("dataset does not contain column time.min", call. = TRUE)
  if (!(c("compound") %in% colnames(dataset)))
    stop("dataset does not contain column compound", call. = TRUE)
  if (!(c("isotopolog") %in% colnames(dataset)))
    stop("dataset does not contain column isotopolog", call. = TRUE)
  if (!(c("ions.incremental") %in% colnames(dataset)))
    stop("dataset does not contain column ions.incrementalo", call. = TRUE)
  if (!(c("tic") %in% colnames(dataset)))
    stop("dataset does not contain column tic", call. = TRUE)
  if (!(c("it.ms") %in% colnames(dataset)))
    stop("dataset does not contain column it.ms",  call. = TRUE)


  df.out <-
    dataset %>% dplyr::group_by(.data$filename) %>% dplyr::mutate(TICxIT = .data$tic * .data$it.ms) %>% #edit 28-Feb-2022 enable multiple dual inlet files
    dplyr::filter(
      .data$TICxIT > stats::quantile(.data$TICxIT, truncate_extreme / 100) &
        .data$TICxIT < stats::quantile(.data$TICxIT, 1 - truncate_extreme / 100)
    ) %>%
    dplyr::select(-.data$TICxIT)

  return(df.out)
}


#' @title Basic  filtering of IsoX data
#' @description A basic generic filter for filenames, isotopocules, compounds and time ranges
#' @param dataset The data frame to be filtered
#' @param isotopocules Vector of isotopocules to select
#' @param base_peak Name of base peak to select
#' @param filenames Vector of filenames to select
#' @param compounds Vector of compounds files to select
#' @param time_min Minimum time in minutes
#' @param time_max Maximum time in minutes
#' @return Filtered tibble
#' @export
orbi_filter_isox <- function(dataset, isotopocules, base_peak, filenames, compounds, time_min, time_max) {

  # safety checks
  if (missing(dataset))
    stop("no dataset supplied", call. = TRUE)
  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)
  if (ncol(dataset) < 8)
    stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
  if (nrow(dataset) < 1)
    stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)

  if (missing(isotopocules))
    stop("input for isotopocules missing", call. = TRUE)
  if (missing(base_peak))
    stop("input for base_peak missing", call. = TRUE)
  if (missing(filenames))
    stop("input for filenames missing", call. = TRUE)
  if (missing(filenames))
    stop("input for filenames missing", call. = TRUE)
  if (missing(compounds))
    stop("input for compounds missing", call. = TRUE)
  if (missing(time_min))
    stop("input for time_min missing", call. = TRUE)
  if (missing(time_max))
    stop("input for time_max missing", call. = TRUE)


  if (!(is.vector(filenames)))
    stop("filenames needs to be a vector of names", call. = TRUE)
  if (!(is.vector(isotopocules)))
    stop("isotopocules needs to be a vector of names", call. = TRUE)
  if (!(is.vector(compounds)))
    stop("compounds needs to be a vector of names", call. = TRUE)
  if (!(is.character(base_peak)))
    stop("base_peak needs to be a character string", call. = TRUE)

  if (!(is.numeric(time_min)))
    stop("time_min needs to be a number", call. = TRUE)
  if (!(is.numeric(time_max)))
    stop("time_max needs to be a number", call. = TRUE)


  # check that requires columns are present
  if (!(c("filename") %in% colnames(dataset)))
    stop("dataset does not contain column filename", call. = TRUE)
  if (!(c("scan.no") %in% colnames(dataset)))
    stop("dataset does not contain column scan.no", call. = TRUE)
  if (!(c("time.min") %in% colnames(dataset)))
    stop("dataset does not contain column time.min", call. = TRUE)
  if (!(c("compound") %in% colnames(dataset)))
    stop("dataset does not contain column compound", call. = TRUE)
  if (!(c("isotopolog") %in% colnames(dataset)))
    stop("dataset does not contain column isotopolog", call. = TRUE)
  if (!(c("ions.incremental") %in% colnames(dataset)))
    stop("dataset does not contain column ions.incrementalo", call. = TRUE)
  if (!(c("tic") %in% colnames(dataset)))
    stop("dataset does not contain column tic", call. = TRUE)
  if (!(c("it.ms") %in% colnames(dataset)))
    stop("dataset does not contain column it.ms",  call. = TRUE)


  df.out <- dataset %>%
    # isotopolog filter
    dplyr::filter(.data$isotopolog %in% c(isotopocules, base_peak)) %>% #maybe this line should be moved out of the core function!
    # file name filter
    {
      if (!"all" %in% filenames)
        dplyr::filter(., .data$filename %in% filenames)
      else
        .
    } %>%
    # compounds filter
    {
      if (!"all" %in% compounds)
        dplyr::filter(., .data$compound %in% compounds)
      else
        .
    } %>%
    # time range filter
    dplyr::filter(.data$time.min >= time_min, .data$time.min <= time_max)


  return(df.out)
}


# Functions to calculate stats --------------------------------------------

# isox data manipulation

#' @title Standard error
#' @description Calculates standard error
#' @param x Vector to compute standard error from
#' @return Standard error

calculate_se <- function(x) {

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  stats::sd(x) / sqrt(length(x))
}

#' @title Geometric mean
#' @description  Define 'gmean' to calculate geometic mean
#'
#' @param x value to compute geometric mean from
#'
#' @return The calculated geometric mean

calculate_gmean <- function(x) {

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  exp(mean(log(x)))
} #define geometric mean

#' @title Standard deviation (geometric)
#' @description  The function calculate_gsd() is used to calculate geometric standard deviations
#' @param x A vector of values from which to compute geometric standard deviation
#'
#' @return The calculated geometric standard deviation

calculate_gsd <- function(x) {

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  exp(mean(log(x)) + stats::sd(log(x))) - exp(mean(log(x)))
}

#' @title Standard error (geometric)
#' @description  The function calculate_gse() is used to calculate geometric standard errors
#'
#' @param x A vector of values from which to compute geometric standard errors
#'
#' @return The calculated geometric standard error

calculate_gse <- function(x) {

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  (exp(mean(log(x)) + stats::sd(log(x))) - exp(mean(log(x)))) / sqrt(length(x))
}

#' @title Estimate the ratios with a linear regression of x, y values
#' @description  The function calculate_slope() is used to the slope of x, y values used in a ratio
#'
#' @param x A vector of values used as ratio nominator
#' @param y A vector of values used as ratio denominator
#' @details The slope is calculates from a linear model that is weighted by the nominator x, using stats::lm(x ~ y + 0, weights = x).
#'
#' @return The calculated slope, an estimate of the ratio x/y

calculate_slope <- function(x, y) {

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  #basic checks
  if (!(is.vector(y)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(y)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(y) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  if (length(x) != length(y))
    stop("Length of x and y need to be equal", call. = TRUE)


  model <-
    stats::lm(x ~ y + 0, weights = x) #Note order of x and y to get correct slope!
  sl <- model$coefficients[[1]]
  sl
}

#' @title Use a weighted sum to estimate the ratios
#' @description The function calculate_weighted.vector.sum () is used to calculate ratios by weighted sums of x and y values
#'
#' @param x A vector of values used as ratio nominator
#' @param y A vector of values used as ratio denominator
#' @details The weighing function ensures that each scan contributes equal weight to the ratio calculation,
#' i.e. scans with more ions in the Orbitrap do not contribute disproportionally to the total sum of x and y that is used to calculate x/y.
#' @return The calculated ratio x/y

calculate_weighted.vector.sum <- function(x, y) {

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  #basic checks
  if (!(is.vector(y)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(y)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(y) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  if (length(x) != length(y))
    stop("Length of x and y need to be equal", call. = TRUE)



  df <- cbind(x, y)

  avg.ions <- (sum(df[, 1]) + sum(df[, 2])) / length(df[, 1])

  scan.ions <- (df[, 1] + df[, 2])

  weighted.x <- avg.ions / scan.ions  * as.numeric(df[, 1])
  weighted.y <- avg.ions / scan.ions  * as.numeric(df[, 2])
  ratio <- sum(weighted.x) / sum(weighted.y)
  ratio
}

#' @title Calculate ratio
#' @description Ratio calculation between peaks of interest. NOTE: The formula used to average ratios matters! Do not simply use arithmetic mean.
#'
#' @param peak1 Peak 1 of interest
#' @param peak2 Peak 2 of interest
#' @param ratio.method The desired method of computing ratio
#'
#' @return calculated ratio between peak1 and peak2 with selected ratio method

orbi_calculate_ratio <-
  function(peak1,
           peak2,
           ratio.method = c("mean",
                            "sum",
                            "median",
                            "geometric.mean",
                            "slope",
                            "weighted.vector.sum")) {
    if (ratio.method == "mean") {
      o <- base::mean(peak1 / peak2)
      o
    } else {
      if (ratio.method == "slope") {
        o <- calculate_slope(peak1, peak2)
        o
      } else{
        if (ratio.method == "sum") {
          o <-  base::sum(peak1) / sum(peak2)
          o
        } else{
          if (ratio.method == "geometric.mean") {
            o <- calculate_gmean(peak1 / peak2)
            o
          } else{
            if (ratio.method == "weighted.vector.sum") {
              o <- calculate_weighted.vector.sum(peak1, peak2)
              o
            } else{
              if (ratio.method == "median") {
                o <-
                  stats::median(peak1 / peak2)
                o
              } else{
                print(
                  "`ratio.method` has to be `mean`, `sum`, `median`, `geometric.mean`, `slope` or `weighted.vector.sum`"
                )
              }
            }
          }
        }
      }
    }
  }
