# Common utility functions

#' @title Filter weak isotopocules
#' @description Remove isotopocules that are not consistently detected across scans with `orbi_filter_weak()`
#'
#' @param dataset Simplified IsoX data to be processed
#' @param min_percent Set threshold. Isotopocule must be observed in at least  x percent of scans
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#'                      orbi_simplify_isox() %>%
#'                      orbi_filter_weak(min_percent = 2)
#'
#' @return Filtered data frame (tibble)
#' @export
orbi_filter_weak <-
  function(dataset, min_percent) {

    # safety checks
    if (missing(dataset))
      stop("no dataset supplied", call. = TRUE)
    if (is.data.frame(dataset) == FALSE)
      stop("dataset must be a data frame",  call. = TRUE)
    if (ncol(dataset) < 8)
      stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
    if (nrow(dataset) < 1)
      stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)

    if (missing(min_percent))
      stop("value for min_percent missing", call. = TRUE)

    if (!(is.numeric(min_percent)))
      stop("min_percent needs to be a number", call. = TRUE)
    if (!(min_percent >= 0 && min_percent <=90))
      stop("min_percent needs to be between 0 and 90 ", call. = TRUE)


    # check that requires columns are present
    if (!(c("filename") %in% colnames(dataset)))
      stop("dataset does not contain column filename", call. = TRUE)
    if (!(c("scan.no") %in% colnames(dataset)))
      stop("dataset does not contain column scan.no", call. = TRUE)
    if (!(c("time.min") %in% colnames(dataset)))
      stop("dataset does not contain column time.min", call. = TRUE)
    if (!(c("compound") %in% colnames(dataset)))
      stop("dataset does not contain column compound", call. = TRUE)
    if (!(c("isotopocule") %in% colnames(dataset)))
      stop("dataset does not contain column isotopocule", call. = TRUE)
    if (!(c("ions.incremental") %in% colnames(dataset)))
      stop("dataset does not contain column ions.incremental", call. = TRUE)
    if (!(c("tic") %in% colnames(dataset)))
      stop("dataset does not contain column tic", call. = TRUE)
    if (!(c("it.ms") %in% colnames(dataset)))
      stop("dataset does not contain column it.ms",  call. = TRUE)

    remove.df <- dataset %>%
      dplyr::group_by(.data$filename) %>%
      dplyr::mutate(n.scans = max(.data$scan.no) - min(.data$scan.no)) %>% #FIXME: implement a more general solution here
      dplyr::group_by(.data$filename, .data$compound, .data$isotopocule) %>%
      dplyr::mutate(i.scans = length(.data$scan.no)) %>%
      dplyr::filter(.data$i.scans < min_percent / 100 * .data$n.scans) %>% # => update selection in GUI?, add message? used previously `input$rare`
      dplyr::select(-.data$n.scans, -.data$i.scans) %>% droplevels() %>% as.data.frame()


    df.out <-
      anti_join(
        dataset,
        remove.df,
        by = c(
          "filename",
          "scan.no",
          "time.min",
          "compound",
          "isotopocule",
          "ions.incremental",
          "tic",
          "it.ms"
        )
      )

    return(df.out)

  }



#' @title Filter to remove minor satellite peaks
#' @description Remove minor signals (e.g., satellite peaks) that were reported by IsoX
#' @param dataset A data frame or tibble produced from IsoX data by `orbi_simplify_isox()`
#' @details The `orbi_filter_satellitePeaks()` function removes minor signals for an isotopocule that have been reported by IsoX.
#' These are often small `satellite peaks` generated by the Fourier transform.
#' If there are signal of high intensity or very many signals, this can indicate that the m/z and tolerance setting used for processing .raw files with IsoX were incorrect.
#'
#'@examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#' orbi_simplify_isox() %>%
#' orbi_filter_satellitePeaks()
#'
#' @return Filtered data frame (tibble)
#' @export
orbi_filter_satellitePeaks <- function(dataset) {

  # safety checks
  if (missing(dataset))
    stop("no dataset supplied", call. = TRUE)
  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)
  if (ncol(dataset) < 8)
    stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
  if (nrow(dataset) < 1)
    stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)


  # check that requires columns are present
  if (!(c("filename") %in% colnames(dataset)))
    stop("dataset does not contain column filename", call. = TRUE)
  if (!(c("scan.no") %in% colnames(dataset)))
    stop("dataset does not contain column scan.no", call. = TRUE)
  if (!(c("time.min") %in% colnames(dataset)))
    stop("dataset does not contain column time.min", call. = TRUE)
  if (!(c("compound") %in% colnames(dataset)))
    stop("dataset does not contain column compound", call. = TRUE)
  if (!(c("isotopocule") %in% colnames(dataset)))
    stop("dataset does not contain column isotopocule", call. = TRUE)
  if (!(c("ions.incremental") %in% colnames(dataset)))
    stop("dataset does not contain column ions.incremental", call. = TRUE)
  if (!(c("tic") %in% colnames(dataset)))
    stop("dataset does not contain column tic", call. = TRUE)
  if (!(c("it.ms") %in% colnames(dataset)))
    stop("dataset does not contain column it.ms",  call. = TRUE)

  df.out <- dataset %>%
    dplyr::group_by(.data$filename,
                    .data$compound,
                    .data$scan.no,
                    .data$isotopocule) %>%
    dplyr::filter(.data$ions.incremental == max(.data$ions.incremental))

  return(df.out)
}


#' @title Filter to remove extreme scans
#' @description Remove extreme scans based on TIC x Injection time with `orbi_filter_TICxIT()`
#' @param dataset Simplified IsoX file to have `TICxIT` outliers removed
#' @param truncate_extreme Remove extreme scans (percentage) based on TIC x Injection time. A number between 0 and 10.
#' @details The `orbi_filter_TICxIT()` function removes scans that are outliers. TIC multiplied by injection time serves as an estimate for the number of ions in the Orbitrap. The filter is a basic truncation that removed x % of scans with maximal or minimal ion estimates.
#'
#'@examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#' orbi_simplify_isox() %>%
#' orbi_filter_TICxIT(truncate_extreme = 1)
#'
#' @return Filtered data frame (tibble)
#' @export
orbi_filter_TICxIT <- function(dataset, truncate_extreme) {

  # safety checks
  if (missing(dataset))
    stop("no dataset supplied", call. = TRUE)
  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)
  if (ncol(dataset) < 8)
    stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
  if (nrow(dataset) < 1)
    stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)

  if (missing(truncate_extreme))
    stop("value for truncate_extreme missing", call. = TRUE)

  if (!(is.numeric(truncate_extreme)))
    stop("truncate_extreme needs to be a number", call. = TRUE)
  if (!(truncate_extreme >= 0 && truncate_extreme <=10))
    stop("truncate_extremet needs to be between 0 and 10 ", call. = TRUE)



  # check that requires columns are present
  if (!(c("filename") %in% colnames(dataset)))
    stop("dataset does not contain column filename", call. = TRUE)
  if (!(c("scan.no") %in% colnames(dataset)))
    stop("dataset does not contain column scan.no", call. = TRUE)
  if (!(c("time.min") %in% colnames(dataset)))
    stop("dataset does not contain column time.min", call. = TRUE)
  if (!(c("compound") %in% colnames(dataset)))
    stop("dataset does not contain column compound", call. = TRUE)
  if (!(c("isotopocule") %in% colnames(dataset)))
    stop("dataset does not contain column isotopocule", call. = TRUE)
  if (!(c("ions.incremental") %in% colnames(dataset)))
    stop("dataset does not contain column ions.incremental", call. = TRUE)
  if (!(c("tic") %in% colnames(dataset)))
    stop("dataset does not contain column tic", call. = TRUE)
  if (!(c("it.ms") %in% colnames(dataset)))
    stop("dataset does not contain column it.ms",  call. = TRUE)


  df.out <-
    dataset %>% dplyr::group_by(.data$filename) %>% dplyr::mutate(TICxIT = .data$tic * .data$it.ms) %>% #edit 28-Feb-2022 enable multiple dual inlet files
    dplyr::filter(
      .data$TICxIT > stats::quantile(.data$TICxIT, truncate_extreme / 100) &
        .data$TICxIT < stats::quantile(.data$TICxIT, 1 - truncate_extreme / 100)
    ) %>%
    dplyr::select(-.data$TICxIT)

  return(df.out)
}


#' @title Basic filtering of IsoX data
#' @description A basic filter function `orbi_filter_isox()` for file names, isotopocules, compounds and time ranges
#' @param dataset The data frame to be filtered
#' @param filenames Vector of file names to select
#' @param compounds Vector of compounds files to select
#' @param isotopocules Vector of isotopocules to select
#' @param time_min Minimum time in minutes
#' @param time_max Maximum time in minutes
#'
#'@examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#' orbi_simplify_isox() %>%
#' orbi_filter_isox(filenames = c("s3744"),
#' compounds = c("HSO4-"),
#' isotopocules = c("M0"),
#' time_min = 0,
#' time_max = 1)
#'
#' @return  Filtered data frame (tibble)
#' @export
orbi_filter_isox <- function(dataset, filenames, isotopocules, compounds, time_min, time_max) {

  # safety checks
  if (missing(dataset))
    stop("no dataset supplied", call. = TRUE)
  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)
  if (ncol(dataset) < 8)
    stop("dataset must have at least 8 columns: ", ncol(dataset), call. = TRUE)
  if (nrow(dataset) < 1)
    stop("dataset contains no rows: ", nrow(dataset), call. = TRUE)

  if (missing(isotopocules))
    stop("input for isotopocules missing", call. = TRUE)
  if (missing(filenames))
    stop("input for filenames missing", call. = TRUE)
  if (missing(filenames))
    stop("input for filenames missing", call. = TRUE)
  if (missing(compounds))
    stop("input for compounds missing", call. = TRUE)
  if (missing(time_min))
    stop("input for time_min missing", call. = TRUE)
  if (missing(time_max))
    stop("input for time_max missing", call. = TRUE)


  if (!(is.vector(filenames)))
    stop("filenames needs to be a vector of names", call. = TRUE)
  if (!(is.vector(isotopocules)))
    stop("isotopocules needs to be a vector of names", call. = TRUE)
  if (!(is.vector(compounds)))
    stop("compounds needs to be a vector of names", call. = TRUE)

  if (!(is.numeric(time_min)))
    stop("time_min needs to be a number", call. = TRUE)
  if (!(is.numeric(time_max)))
    stop("time_max needs to be a number", call. = TRUE)


  # check that requires columns are present
  if (!(c("filename") %in% colnames(dataset)))
    stop("dataset does not contain column filename", call. = TRUE)
  if (!(c("scan.no") %in% colnames(dataset)))
    stop("dataset does not contain column scan.no", call. = TRUE)
  if (!(c("time.min") %in% colnames(dataset)))
    stop("dataset does not contain column time.min", call. = TRUE)
  if (!(c("compound") %in% colnames(dataset)))
    stop("dataset does not contain column compound", call. = TRUE)
  if (!(c("isotopocule") %in% colnames(dataset)))
    stop("dataset does not contain column isotopocule", call. = TRUE)
  if (!(c("ions.incremental") %in% colnames(dataset)))
    stop("dataset does not contain column ions.incremental", call. = TRUE)
  if (!(c("tic") %in% colnames(dataset)))
    stop("dataset does not contain column tic", call. = TRUE)
  if (!(c("it.ms") %in% colnames(dataset)))
    stop("dataset does not contain column it.ms",  call. = TRUE)


  df.out <- dataset %>%
    # isotopocule filter
    dplyr::filter(.data$isotopocule %in% c(isotopocules)) %>%
    # file name filter
    {
      if (!"all" %in% filenames)
        dplyr::filter(., .data$filename %in% filenames)
      else
        .
    } %>%
    # compounds filter
    {
      if (!"all" %in% compounds)
        dplyr::filter(., .data$compound %in% compounds)
      else
        .
    } %>%
    # time range filter
    dplyr::filter(.data$time.min >= time_min, .data$time.min <= time_max)


  return(df.out)
}


# Functions to calculate stats --------------------------------------------

# @title Internal function to calculate standard error
# @description The fuction `calculate_se()` computes a regular standard error
# @keywords internal
# @param x A numeric vector used to calculate a standard error
# @return The calculated standard error

calculate_se <- function(x) {

  # safety checks
  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  stats::sd(x) / sqrt(length(x))
}

# @title Internal function to calculate geometric mean
# @description  The function `calculate_gmean()` is used to calculate geometric means
# @keywords internal
# @param x A numeric vector used to calculate the geometric mean
# @return The calculated geometric mean

calculate_gmean <- function(x) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  exp(mean(log(x)))
}


# @title Internal function to calculate standard deviation (geometric)
# @description  The function `calculate_gsd()` is used to calculate geometric standard deviations
# @keywords internal
# @param x A numeric values used to calculate the geometric standard deviation
# @return The calculated geometric standard deviation
calculate_gsd <- function(x) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  exp(mean(log(x)) + stats::sd(log(x))) - exp(mean(log(x)))
}

# @title Internal function to calculate standard error (geometric)
# @description  The function `calculate_gse()` is used to calculate geometric standard errors
# @keywords internal
# @param x A vector of values used to calculate geometric standard errors
# @return The calculated geometric standard error
calculate_gse <- function(x) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  (exp(mean(log(x)) + stats::sd(log(x))) - exp(mean(log(x)))) / sqrt(length(x))
}

# @title Internal function for ratio.method `slope`
# @description  The function `calculate_slope()` is used to estimate the slope of x, y values used in a ratio
# @keywords internal
# @param x A vector of values used as ratio nominator
# @param y A vector of values used as ratio denominator
# @details The slope is calculates from a linear model that is weighted by the nominator x, using stats::lm(x ~ y + 0, weights = x)
# @return The calculated slope, an estimate of the ratio x/y
calculate_slope <- function(x, y) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  if (missing(y))
    stop("input vector for y supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  #basic checks
  if (!(is.vector(y)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(y)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(y) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  if (length(x) != length(y))
    stop("Length of x and y need to be equal", call. = TRUE)


  model <-
    stats::lm(x ~ y + 0, weights = x) #Note order of x and y to get correct slope!
  sl <- model$coefficients[[1]]
  sl
}

# @title Internal function for ratio.method `weighted.sum`
# @description The function `calculate_weighted.sum()` is used to calculate ratios by weighted sums of x and y values
# @keywords internal
# @param x A vector of values used as ratio nominator
# @param y A vector of values used as ratio denominator
# @details The weighing function ensures that each scan contributes equal weight to the ratio calculation,
# i.e. scans with more ions in the Orbitrap do not contribute disproportionally to the total sum of x and y that is used to calculate x/y.
# @return The calculated ratio x/y
calculate_weighted.sum <- function(x, y) {

  if (missing(x))
    stop("input vector for x supplied", call. = TRUE)

  if (missing(y))
    stop("input vector for y supplied", call. = TRUE)

  #basic checks
  if (!(is.vector(x)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(x)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(x) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  #basic checks
  if (!(is.vector(y)))
    stop("x needs to be a vector", call. = TRUE)
  if (!(is.numeric(y)))
    stop("x needs to be a numeric vector", call. = TRUE)

  if (length(y) <=1)
    stop("Length of x needs to be > 1: ", length(x), call. = TRUE)

  if (length(x) != length(y))
    stop("Length of x and y need to be equal", call. = TRUE)

  df <- cbind(x, y)

  avg.ions <- (sum(df[, 1]) + sum(df[, 2])) / length(df[, 1])

  scan.ions <- (df[, 1] + df[, 2])

  weighted.x <- avg.ions / scan.ions  * as.numeric(df[, 1])
  weighted.y <- avg.ions / scan.ions  * as.numeric(df[, 2])
  ratio <- sum(weighted.x) / sum(weighted.y)
  ratio
}

# @title Internal function to calculate ratio
# @description Ratio calculation between isotopocules of interest.
#
# Please note well: The formula used to calculate ion ratios matters! Do not simply use arithmetic mean.
#
# @param numerator Isotopocule(s) used as numerator
# @param denominator Isotopocule used as denominator
# @param ratio.method The desired method of computing the ratio
# @details Description of options for ratio.method:
#
# `mean`: arithmetic mean of ratios from individual scans.
#
# `sum`: sum of all ions of the numerator across all scans divided by the sum of all ions observed for the denominator across all scans.
#
# `geometric.mean`: geometric mean of ratios from individual scans.
#
# `slope`: The ratio is calculated using the slope from a linear model that is weighted by the numerator x, using `stats::lm(x ~ y + 0, weights = x)`.
#
# `weighted.sum`: The weighing function ensures that each scan contributes equal weight to the ratio calculation,
# i.e. scans with more ions in the Orbitrap do not contribute disproportionally to the total sum of x and y that is used to calculate x/y.
#
# @examples
# fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
# df <- orbi_read_isox(filepath = fpath) %>%
#                      orbi_simplify_isox() %>%
#                      orbi_basepeak(basepeak = "M0")
# df2 <- orbi_calculate_ratio(numerator = df$ions.incremental, denominator = df$Basepeak.Ions, ratio.method =  "sum")
#
# @return Calculated ratio between isotopocules defined as numerator(s) and denominator, using one of the ratio methods.
# @export

orbi_calculate_ratio <-
  function(numerator,
           denominator,
           ratio.method = c("mean",
                            "sum",
                            "median",
                            "geometric.mean",
                            "slope",
                            "weighted.sum")) {


    if (missing(numerator))
      stop("no input for numerator supplied", call. = TRUE)

    if (is.numeric(numerator) == FALSE)
      stop("numerator must be a numeric vector",  call. = TRUE)

    if (missing(denominator))
      stop(" no input for denominator supplied", call. = TRUE)
    if (is.numeric(denominator) == FALSE)
      stop("denominator must be a numeric vector",  call. = TRUE)


    if (ratio.method == "mean") {
      o <- base::mean(numerator / denominator)
      o
    } else {
      if (ratio.method == "slope") {
        o <- calculate_slope(numerator, denominator)
        o
      } else{
        if (ratio.method == "sum") {
          o <-  base::sum(numerator) / sum(denominator)
          o
        } else{
          if (ratio.method == "geometric.mean") {
            o <- calculate_gmean(numerator / denominator)
            o
          } else{
            if (ratio.method == "weighted.sum") {
              o <- calculate_weighted.sum(numerator, denominator)
              o
            } else{
              if (ratio.method == "median") {
                o <-
                  stats::median(numerator / denominator)
                o
              } else{
                print(
                  "`ratio.method` has to be `mean`, `sum`, `median`, `geometric.mean`, `slope` or `weighted.sum`"
                )
              }
            }
          }
        }
      }
    }
  }

#' @title Assign the base peak
#' @description `orbi_basepeak()` assigns one isotopocule in the data frame as the base peak
#' @param dataset A data frame from a an IsoX output. Needs to contain columns for `filename`, `compound`, `scan.no`, `isotopocule`, `ions.incremental`.
#' @param basepeak The isotopocule used as base peak in `orbi_calculate_ratio()`
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#'                      orbi_simplify_isox() %>%
#'                      orbi_basepeak(basepeak = "M0")
#'
#' @returns Input data frame plus two columns called `Basepeak` and `Basepeak.Ions`
#' @export
orbi_basepeak <- function(dataset, basepeak) {

  #basic checks
  if (missing(dataset))
    stop("no input for dataset supplied", call. = TRUE)

  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)

  if (missing(basepeak))
    stop(" no input for basepeak supplied", call. = TRUE)
  if (is.character(basepeak) == FALSE)
    stop("denominator must be a basepeak vector",  call. = TRUE)
  if (length(basepeak) > 1)
    stop("only one baspeak can be assigned",  call. = TRUE)

  # check that requires columns are present
  if (!(c("filename") %in% colnames(dataset)))
    stop("dataset does not contain column filename", call. = TRUE)
  if (!(c("scan.no") %in% colnames(dataset)))
    stop("dataset does not contain column scan.no", call. = TRUE)
  if (!(c("compound") %in% colnames(dataset)))
    stop("dataset does not contain column compound", call. = TRUE)
  if (!(c("isotopocule") %in% colnames(dataset)))
    stop("dataset does not contain column isotopocule", call. = TRUE)
  if (!(c("ions.incremental") %in% colnames(dataset)))
    stop("dataset does not contain column ions.incremental", call. = TRUE)



  # Annotation: Identify `base peak` for each scan

  df.sel <- dataset  %>%
    dplyr::select(.data$filename,
                  .data$compound,
                  .data$scan.no,
                  .data$isotopocule,
                  .data$ions.incremental) %>%
    dplyr::group_by(.data$filename, .data$scan.no) %>%
    dplyr::filter(.data$isotopocule == basepeak) %>%
    dplyr::mutate(Basepeak = factor(.data$isotopocule),
                  Basepeak.Ions = .data$ions.incremental) %>%
    dplyr::select(.data$filename,
                  .data$compound,
                  .data$scan.no,
                  .data$Basepeak,
                  .data$Basepeak.Ions) %>%
    as.data.frame()

  df.out <- merge(df.sel, dataset, all = TRUE)

  df.out <-
    df.out %>% dplyr::filter(.data$isotopocule != basepeak) %>% droplevels()

  return(df.out)
}


#' @title Calculate the results table
#' @description Contains the logic to generate the results table
#' @param dataset A processed data frame from IsoX output
#' @param ratio.method Method  for computing the ratio; passed to `orbi_calculate_ratio()`
#'
#' @examples
#' fpath <- system.file("extdata", "testfile_Flow_Exploration_small.isox", package = "isoorbi")
#' df <- orbi_read_isox(filepath = fpath) %>%
#'       orbi_simplify_isox() %>% orbi_basepeak(basepeak = "M0")  %>%
#'       orbi_calculate_results(ratio.method = "sum")
#'
#' @details Description of options for ratio.method:
#'
#' `mean`: arithmetic mean of ratios from individual scans.
#'
#' `sum`: sum of all ions of the numerator across all scans divided by the sum of all ions observed for the denominator across all scans.
#'
#' `geometric.mean`: geometric mean of ratios from individual scans.
#'
#' `slope`: The ratio is calculated using the slope from a linear model that is weighted by the numerator x, using stats::lm(x ~ y + 0, weights = x).
#'
#' `weighted.sum`: The weighing function ensures that each scan contributes equal weight to the ratio calculation,
#' i.e. scans with more ions in the Orbitrap do not contribute disproportionally to the total sum of x and y that is used to calculate x/y.
#'
#' @return Returns table containing `filename`, `compound`,  `Basepeak`, `Isotopocule`, `Ratio`, `Ratio.SEM`, `relSE.permil`, `Shot.Noise.permil`, `No.of.Scans`, `Mins.to.1mio`
#' @export
orbi_calculate_results <- function(dataset, ratio.method) {

  #basic checks
  if (missing(dataset))
    stop("no input for dataset supplied", call. = TRUE)

  if (is.data.frame(dataset) == FALSE)
    stop("dataset must be a data frame",  call. = TRUE)

  if (missing(ratio.method))
    stop("no input for ratio.method supplied", call. = TRUE)

  ratio.options <- c("mean",
                     "sum",
                     "median",
                     "geometric.mean",
                     "slope",
                     "weighted.sum")

  if (!(ratio.method %in% ratio.options))
    stop(cat("ratio.method must be on of the following: ", ratio.options,"\n",sep = " "),  call. = TRUE)




  # check that requires columns are present
  if (!(c("filename") %in% colnames(dataset)))
    stop("dataset does not contain column filename", call. = TRUE)
  if (!(c("compound") %in% colnames(dataset)))
    stop("dataset does not contain column compound", call. = TRUE)
  if (!(c("isotopocule") %in% colnames(dataset)))
    stop("dataset does not contain column isotopocule", call. = TRUE)
  if (!(c("ions.incremental") %in% colnames(dataset)))
    stop("dataset does not contain column ions.incrementalo", call. = TRUE)
  if (!(c("time.min") %in% colnames(dataset)))
    stop("dataset does not contain column time.min", call. = TRUE)
  if (!(c("Basepeak") %in% colnames(dataset)))
    stop("dataset does not contain column Basepeak", call. = TRUE)


  df.stat <- dataset  %>%  dplyr::group_by(.data$filename,
                                           .data$compound,
                                          .data$Basepeak,
                                        .data$isotopocule) %>%

    dplyr::mutate(Ratio = orbi_calculate_ratio(.data$ions.incremental, .data$Basepeak.Ions, ratio.method = ratio.method)) %>% #RATIO CALCULATION!

    dplyr::mutate(Ratio.SEM = calculate_se(.data$ions.incremental / .data$Basepeak.Ions))      #For simplicity use basic standard error for all options

  df.stat <- df.stat %>% dplyr::mutate(
    No.of.scans = length(.data$Ratio),
    Mins.to.1mio = (1E6 / sum(.data$ions.incremental)) * (max(.data$time.min) - min(.data$time.min)),
    Shot.Noise.permil = 1000 * (sqrt((
      sum(.data$ions.incremental) + sum(.data$Basepeak.Ions)
    ) / (
      sum(.data$ions.incremental) * sum(.data$Basepeak.Ions)
    ))),
    relSE.permil = 1000 * (.data$Ratio.SEM / .data$Ratio)
  ) %>%

    #Round values for output
    dplyr::mutate(
      Ratio = round(.data$Ratio, 8),
      Ratio.SEM = round(.data$Ratio.SEM, 8),
      Shot.Noise.permil = round(.data$Shot.Noise.permil, 3),
      relSE.permil = round(.data$relSE.permil, 3),
      Mins.to.1mio = round(.data$Mins.to.1mio, 2)
    ) %>%

    dplyr::select(
      .data$filename,
      .data$compound,
      .data$Basepeak,
      .data$isotopocule,
      .data$Ratio,
      .data$Ratio.SEM,
      .data$relSE.permil,
      .data$Shot.Noise.permil,
      .data$No.of.scans,
      .data$Mins.to.1mio
    ) %>%
    unique() %>%
    arrange(.data$filename, .data$isotopocule)

  df.stat <- as.data.frame(df.stat)
  return(df.stat)
}
